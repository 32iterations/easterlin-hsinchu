<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èµ¤åœŸå´å¤šåŠŸèƒ½é¤¨ - 3Då®¤å…§å°è¦½ç³»çµ± (å°ˆæ¥­ç‰ˆ)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            font-family: 'Inter', 'Segoe UI', -apple-system, sans-serif;
            background: #0a0e27;
            overflow: hidden;
            color: #ffffff;
        }

        /* ============== ä¸»å®¹å™¨ ============== */
        #app {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 60px 1fr;
        }

        /* ============== é ‚éƒ¨å°èˆªæ¬„ ============== */
        #topbar {
            background: rgba(10, 14, 39, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 30px;
            z-index: 1000;
        }

        .topbar-left {
            display: flex;
            align-items: center;
            gap: 30px;
        }

        .app-title {
            font-size: 16px;
            font-weight: 600;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            letter-spacing: 1px;
        }

        .mode-switcher {
            display: flex;
            gap: 8px;
            background: rgba(0, 255, 136, 0.1);
            padding: 4px;
            border-radius: 6px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .mode-btn {
            padding: 6px 14px;
            border: none;
            background: transparent;
            color: #888;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: #00ff88;
            color: #000;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        .mode-btn:hover {
            color: #00ff88;
        }

        .topbar-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
            color: #888;
            font-family: 'Courier New', monospace;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .stat-label {
            color: #666;
            font-size: 10px;
        }

        .stat-value {
            color: #00ff88;
            font-weight: 600;
        }

        /* ============== ä¸»å…§å®¹å€ ============== */
        #main-container {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            gap: 1px;
            background: #0a0e27;
        }

        /* ============== å·¦å´é¢æ¿ ============== */
        #left-panel {
            background: rgba(10, 14, 39, 0.9);
            border-right: 1px solid rgba(0, 255, 136, 0.2);
            overflow-y: auto;
            padding: 20px;
            z-index: 501;
        }

        .panel-title {
            font-size: 13px;
            font-weight: 600;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
        }

        .floor-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 30px;
        }

        .floor-btn {
            padding: 10px 12px;
            background: rgba(0, 204, 255, 0.1);
            border: 1px solid rgba(0, 204, 255, 0.3);
            color: #00ccff;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-align: left;
        }

        .floor-btn:hover {
            background: rgba(0, 204, 255, 0.2);
            border-color: rgba(0, 204, 255, 0.6);
        }

        .floor-btn.active {
            background: #00ccff;
            color: #000;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.5);
        }

        .rooms-list {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .room-item {
            padding: 8px 10px;
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.1);
            border-radius: 3px;
            margin-bottom: 6px;
            cursor: pointer;
            font-size: 11px;
            color: #aaa;
            transition: all 0.3s ease;
        }

        .room-item:hover {
            background: rgba(0, 255, 136, 0.15);
            color: #00ff88;
            border-color: rgba(0, 255, 136, 0.3);
        }

        .room-name {
            font-weight: 500;
            color: #00ff88;
            margin-bottom: 2px;
        }

        .room-area {
            font-size: 10px;
            color: #666;
        }

        /* ============== ä¸­å¤® 3D Canvas ============== */
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a3e 100%);
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* ============== å³å´é¢æ¿ ============== */
        #right-panel {
            background: rgba(10, 14, 39, 0.9);
            border-left: 1px solid rgba(255, 0, 255, 0.2);
            overflow-y: auto;
            padding: 20px;
        }

        .info-card {
            background: rgba(255, 0, 255, 0.05);
            border: 1px solid rgba(255, 0, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .card-title {
            font-size: 14px;
            font-weight: 600;
            color: #ff00ff;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.3);
        }

        .card-content {
            font-size: 12px;
            color: #ccc;
            line-height: 1.6;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 0, 255, 0.1);
        }

        .info-label {
            color: #888;
            font-weight: 500;
        }

        .info-value {
            color: #00ff88;
            font-weight: 600;
        }

        /* ============== æ‡¸æµ®æ§åˆ¶é¢æ¿ ============== */
        .floating-panel {
            position: fixed;
            background: rgba(10, 14, 39, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 170, 0, 0.3);
            border-radius: 8px;
            padding: 12px 15px;
            font-size: 11px;
            color: #ffaa00;
            z-index: 503;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.2);
        }

        #control-panel {
            bottom: 20px;
            right: 20px;
        }

        .control-title {
            text-transform: uppercase;
            font-weight: 600;
            margin-bottom: 10px;
            letter-spacing: 1px;
            font-size: 10px;
        }

        .control-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .ctrl-btn {
            padding: 6px 10px;
            background: rgba(255, 170, 0, 0.15);
            border: 1px solid rgba(255, 170, 0, 0.3);
            color: #ffaa00;
            cursor: pointer;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .ctrl-btn:hover {
            background: rgba(255, 170, 0, 0.3);
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.3);
        }

        /* ============== å°åœ°åœ– ============== */
        #minimap {
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 200px;
            z-index: 505;
            pointer-events: auto;
            overflow: hidden;
            border-radius: 8px;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            border-radius: 6px;
            border: 1px solid rgba(0, 204, 255, 0.3);
            display: block;
            overflow: hidden;
        }

        /* ============== æç¤ºç³»çµ± ============== */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 4px;
            padding: 8px 10px;
            font-size: 11px;
            color: #00ff88;
            pointer-events: none;
            z-index: 400;
            white-space: nowrap;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.2);
        }

        /* ============== æ»¾å‹•æ¢ç¾åŒ– ============== */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 136, 0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 136, 0.5);
        }

        /* ============== åŠ è¼‰å‹•ç•« ============== */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading {
            animation: pulse 1.5s infinite;
        }

        /* ============== éŸ¿æ‡‰å¼è¨­è¨ˆ ============== */
        @media (max-width: 1400px) {
            #main-container {
                grid-template-columns: 1fr 300px;
            }
            #left-panel {
                display: none;
            }
        }

        /* FPS æ¨¡å¼æµ®å‹•æˆ¿é–“é¢æ¿ */
        #fps-room-panel {
            position: fixed;
            left: 20px;
            top: 100px;
            width: 280px;
            max-height: 400px;
            background: rgba(10, 14, 39, 0.95);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            padding: 15px;
            z-index: 510;
            display: none;
            overflow-y: auto;
            backdrop-filter: blur(5px);
        }

        #fps-room-panel.visible {
            display: block;
        }

        #fps-room-panel .panel-title {
            font-size: 12px;
            font-weight: 600;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #fps-room-toggle-btn {
            position: fixed;
            left: 20px;
            top: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid rgba(0, 255, 136, 0.4);
            color: #00ff88;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 511;
            transition: all 0.3s ease;
        }

        #fps-room-toggle-btn:hover {
            background: rgba(0, 255, 136, 0.4);
            border-color: rgba(0, 255, 136, 0.8);
        }

        #fps-room-toggle-btn.visible {
            display: flex;
        }

        #fps-rooms-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        @media (max-width: 1000px) {
            #main-container {
                grid-template-columns: 1fr;
            }
            #right-panel {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- èª¿è©¦æ—¥èªŒ - ç§»åˆ°å·¦ä¸‹è§’ï¼Œé¿å…èˆ‡æ§åˆ¶é¢æ¿è¡çª -->
    <div id="debug-log" style="position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.95); color: #0f0; padding: 10px; font-family: monospace; font-size: 10px; max-width: 400px; max-height: 200px; overflow-y: auto; z-index: 100; border: 1px solid #0f0; white-space: pre-wrap; word-wrap: break-word; border-radius: 4px;"><span style="color: #ff0;">ğŸ“‹ LOADING LOG</span></div>

    <!-- FPS æ¨¡å¼æˆ¿é–“åˆ‡æ›æŒ‰éˆ• -->
    <button id="fps-room-toggle-btn" title="åˆ‡æ›æˆ¿é–“é¢æ¿">â˜°</button>

    <!-- FPS æ¨¡å¼æµ®å‹•æˆ¿é–“é¢æ¿ -->
    <div id="fps-room-panel">
        <div class="panel-title">
            æˆ¿é–“åˆ—è¡¨
            <button id="fps-room-close-btn" style="background: none; border: none; color: #00ff88; cursor: pointer; font-size: 14px; padding: 0; width: auto;">âœ•</button>
        </div>
        <div id="fps-rooms-list"></div>
    </div>

    <div id="app">
        <!-- é ‚éƒ¨å°èˆªæ¬„ -->
        <div id="topbar">
            <div class="topbar-left">
                <div class="app-title">ğŸ¢ èµ¤åœŸå´å¤šåŠŸèƒ½é¤¨ 3D å°è¦½ç³»çµ±</div>
                <div class="mode-switcher">
                    <button class="mode-btn active" onclick="switchMode('exterior')">å¤–éƒ¨è¦–è§’</button>
                    <button class="mode-btn" onclick="switchMode('interior')">å…§éƒ¨å°è¦½</button>
                    <button class="mode-btn" onclick="switchMode('fps')">ç¬¬ä¸€äººç¨±</button>
                </div>
            </div>
            <div class="topbar-right">
                <div class="stats">
                    <div class="stat-item">
                        <span class="stat-label">FPS</span>
                        <span class="stat-value" id="fps-display">60</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Objects</span>
                        <span class="stat-value" id="obj-display">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Memory</span>
                        <span class="stat-value" id="mem-display">0MB</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- ä¸»å®¹å™¨ -->
        <div id="main-container">
            <!-- å·¦å´é¢æ¿ -->
            <div id="left-panel">
                <div class="panel-title">æ¨“å±¤å°èˆª</div>
                <div class="floor-list">
                    <button class="floor-btn" onclick="selectFloor('B1')">B1 åœè»Šå ´+æ©Ÿæˆ¿</button>
                    <button class="floor-btn active" onclick="selectFloor('1F')">1F é•·ç…§+AIè¨˜æ†¶</button>
                    <button class="floor-btn" onclick="selectFloor('2F')">2F æ‰˜å¬°+SIDSç›£æ¸¬</button>
                    <button class="floor-btn" onclick="selectFloor('3F')">3F è¦ªå­å…±å­¸</button>
                    <button class="floor-btn" onclick="selectFloor('4F')">4F STEMæ•™å®¤</button>
                </div>

                <div class="panel-title">æˆ¿é–“åˆ—è¡¨</div>
                <div class="rooms-list" id="rooms-list"></div>
            </div>

            <!-- ä¸­å¤® 3D Canvas -->
            <div id="canvas-container"></div>

            <!-- å³å´é¢æ¿ -->
            <div id="right-panel">
                <div id="info-panel"></div>
            </div>
        </div>

        <!-- å°åœ°åœ– -->
        <div class="floating-panel" id="minimap">
            <div class="control-title">æ¨“å±¤å¹³é¢åœ–</div>
            <canvas id="minimap-canvas"></canvas>
        </div>

        <!-- æ§åˆ¶é¢æ¿ -->
        <div class="floating-panel" id="control-panel">
            <div class="control-title">âš™ï¸ æ§åˆ¶</div>
            <div class="control-buttons">
                <button class="ctrl-btn" onclick="toggleWireframe()">ç·šæ¡†</button>
                <button class="ctrl-btn" onclick="toggleAutoRotate()">è‡ªå‹•æ—‹è½‰</button>
                <button class="ctrl-btn" onclick="resetView()">é‡ç½®è¦–è§’</button>
                <button class="ctrl-btn" onclick="toggleHelp()">å¹«åŠ©</button>
            </div>
        </div>
    </div>

    <!-- Import Map ç”¨æ–¼è§£æ Three.js æ¨¡çµ„ä¾è³´ -->
    <script type="importmap">
    {
        "imports": {
            "three": "/libs/three/three.module.js"
        }
    }
    </script>

    <!-- ç•°æ­¥åŠ è¼‰ Three.js åº«å’Œæ§åˆ¶å™¨ï¼ˆä¿®å¾©åŠ è¼‰é˜»å¡å•é¡Œï¼‰ -->
    <script type="module">
        // èª¿è©¦æ—¥èªŒå‡½å¼
        function debugLog(msg) {
            const log = document.getElementById('debug-log');
            if (log) {
                log.innerHTML += '\n' + msg;
                log.scrollTop = log.scrollHeight;
            }
            console.log(msg);
        }

        // ä½¿ç”¨ dynamic import åŠ è¼‰ Three.js å’Œæ§åˆ¶å™¨
        async function loadLibraries() {
            try {
                debugLog('â³ åŠ è¼‰ Three.js...');
                const THREE = await import('/libs/three/three.module.js');
                window.THREE = THREE;
                debugLog('âœ… Three.js å·²åŠ è¼‰ (Scene: ' + (THREE.Scene ? 'âœ“' : 'âœ—') + ')');

                debugLog('â³ åŠ è¼‰ OrbitControls...');
                const { OrbitControls } = await import('/libs/three/OrbitControls.js');
                window.OrbitControls = OrbitControls;
                debugLog('âœ… OrbitControls å·²åŠ è¼‰ (' + (OrbitControls ? 'âœ“' : 'âœ—') + ')');

                debugLog('â³ åŠ è¼‰ PointerLockControls...');
                const { PointerLockControls } = await import('/libs/three/PointerLockControls.js');
                window.PointerLockControls = PointerLockControls;
                debugLog('âœ… PointerLockControls å·²åŠ è¼‰ (' + (PointerLockControls ? 'âœ“' : 'âœ—') + ')');

                debugLog('âœ… æ‰€æœ‰æ¨¡çµ„åŠ è¼‰å®Œæˆ');
            } catch (err) {
                debugLog('âŒ åº«åŠ è¼‰éŒ¯èª¤: ' + err.message);
                console.error('âŒ åº«åŠ è¼‰éŒ¯èª¤:', err);
            }
        }

        loadLibraries();
    </script>
    <script>
        // ==================== å…¨å±€é…ç½® ====================
        const BUILDING_CONFIG = {
            width: 32,
            depth: 20,
            floors: ['B1', '1F', '2F', '3F', '4F', '5F', '6F', '7F'],  // Stage 4åˆè¦ï¼š7å±¤å»ºç¯‰
            floorHeights: [5, 4, 4, 4, 4, 4, 4, 3.5]
        };

        // FPS æ§åˆ¶ç›¸é—œè®Šæ•¸
        let fpsCamera, orbitCamera;
        let fpsControls, pointerLockControls;
        let isPointerLocked = false;
        let currentMode = 'exterior';
        let moveVector = { forward: false, backward: false, left: false, right: false };
        let currentFloor = '1F';
        const FPS_SPEED = 0.15;
        const FPS_HEIGHT = 1.6; // äººçœ¼é«˜åº¦

        // ==================== è¡—æ™¯å°èˆªç³»çµ± (Google Maps Street View é¢¨æ ¼) ====================
        const streetViewNav = {
            enabled: false,
            waypoints: [],  // ç•¶å‰æ¨“å±¤çš„å°èˆªé»
            currentWaypoint: null,
            currentRoom: null,  // ç•¶å‰æ‰€åœ¨æˆ¿é–“
            isTransitioning: false,
            transitionSpeed: 0.05,  // ç›¸æ©Ÿè½‰ç§»é€Ÿåº¦
            navigationMarkers: []  // è¦–è¦ºå°èˆªæ¨™è¨˜
        };
        window.streetViewNav = streetViewNav;

        // ç”Ÿæˆè¡—æ™¯å°èˆªé»
        function generateWaypoints(floor) {
            streetViewNav.waypoints = [];
            const rooms = ROOM_DATA[floor] || [];

            rooms.forEach(room => {
                // åœ¨æ¯å€‹æˆ¿é–“ä¸­å¿ƒå’Œå››å€‹è§’è½æ·»åŠ å°èˆªé»
                const points = [
                    { x: room.x, z: room.z, label: room.name + ' (ä¸­å¿ƒ)' },  // ä¸­å¿ƒ
                    { x: room.x - room.w/3, z: room.z - room.d/3, label: room.name + ' (å·¦å‰)' },  // å·¦å‰
                    { x: room.x + room.w/3, z: room.z - room.d/3, label: room.name + ' (å³å‰)' },  // å³å‰
                ];

                points.forEach(pt => {
                    streetViewNav.waypoints.push({
                        position: new THREE.Vector3(pt.x, FPS_HEIGHT, pt.z),
                        room: room,
                        label: pt.label
                    });
                });
            });
        }

        // å‰µå»ºå°èˆªæ¨™è¨˜è¦–è¦ºåŒ–
        function createNavigationMarkers() {
            // æ¸…é™¤èˆŠæ¨™è¨˜
            streetViewNav.navigationMarkers.forEach(marker => {
                if (marker.parent) {
                    marker.parent.remove(marker);
                }
            });
            streetViewNav.navigationMarkers = [];

            if (!streetViewNav.enabled) return;

            const markerGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const markerMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.7
            });

            streetViewNav.waypoints.forEach(waypoint => {
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.copy(waypoint.position);
                marker.userData = { waypoint: waypoint, isNavigationMarker: true };
                scene.add(marker);
                streetViewNav.navigationMarkers.push(marker);
            });
        }

        // å¹³æ»‘è½‰ç§»åˆ°å°èˆªé»
        function moveToWaypoint(waypoint) {
            if (streetViewNav.isTransitioning) return;

            streetViewNav.isTransitioning = true;
            const startPos = fpsCamera.position.clone();
            const endPos = waypoint.position.clone();
            const duration = 1.5;  // 1.5ç§’è½‰ç§»
            let elapsed = 0;

            function transitionFrame() {
                elapsed += 0.016;  // å‡è¨­60fps
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = progress < 0.5
                    ? 2 * progress * progress
                    : -1 + (4 - 2 * progress) * progress;  // ç·©å…¥ç·©å‡º

                fpsCamera.position.lerpVectors(startPos, endPos, easeProgress);

                if (progress < 1) {
                    requestAnimationFrame(transitionFrame);
                } else {
                    fpsCamera.position.copy(endPos);
                    streetViewNav.currentWaypoint = waypoint;
                    streetViewNav.isTransitioning = false;
                }
            }

            transitionFrame();
        }

        // é€²å…¥æˆ¿é–“å‡½æ•¸ï¼ˆFPSè¦–è§’é€²å…¥æˆ¿é–“ï¼‰
        function enterRoom(roomId) {
            if (streetViewNav.isTransitioning) return;

            // å¾ROOM_DATAä¸­å°‹æ‰¾è©²æˆ¿é–“
            let selectedRoom = null;
            let floorKey = null;

            for (const floor in ROOM_DATA) {
                const room = ROOM_DATA[floor].find(r => r.id === roomId);
                if (room) {
                    selectedRoom = room;
                    floorKey = floor;
                    break;
                }
            }

            if (!selectedRoom) {
                console.warn('æˆ¿é–“æœªæ‰¾åˆ°:', roomId);
                return;
            }

            // æª¢æŸ¥æ˜¯å¦éœ€è¦åˆ‡æ›æ¨“å±¤
            if (floorKey !== currentFloor) {
                selectFloor(floorKey);
            }

            // è¨ˆç®—æˆ¿é–“ä¸­å¿ƒä½ç½®
            const roomCenterX = selectedRoom.x + selectedRoom.w / 2;
            const roomCenterZ = selectedRoom.z + selectedRoom.d / 2;

            // ğŸ”§ FIX: è¨ˆç®—è©²æ¨“å±¤çš„åŸºç¤é«˜åº¦å’Œä¸Šé™é«˜åº¦
            const floorIndex = BUILDING_CONFIG.floors.indexOf(floorKey);
            let floorBaseY = 0;
            if (floorIndex >= 0) {
                for (let i = 0; i < floorIndex; i++) {
                    floorBaseY += BUILDING_CONFIG.floorHeights[i];
                }
            }

            // ç›¸æ©Ÿé€²å…¥æˆ¿é–“ï¼ˆåœ¨æˆ¿é–“ä¸­å¿ƒï¼Œç›¸æ©Ÿé«˜åº¦ç‚ºçœ¼ç›é«˜åº¦ FPS_HEIGHTï¼‰
            const entryHeight = floorBaseY + FPS_HEIGHT;

            // å¹³æ»‘è½‰ç§»åˆ°æˆ¿é–“
            streetViewNav.isTransitioning = true;
            const startPos = fpsCamera.position.clone();
            const endPos = new THREE.Vector3(roomCenterX, entryHeight, roomCenterZ);
            const duration = 1.5;  // 1.5ç§’è½‰ç§»
            let elapsed = 0;

            function transitionToRoomFrame() {
                elapsed += 0.016;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = progress < 0.5
                    ? 2 * progress * progress
                    : -1 + (4 - 2 * progress) * progress;

                fpsCamera.position.lerpVectors(startPos, endPos, easeProgress);
                fpsCamera.lookAt(roomCenterX, entryHeight, roomCenterZ);

                if (progress < 1) {
                    requestAnimationFrame(transitionToRoomFrame);
                } else {
                    fpsCamera.position.copy(endPos);
                    streetViewNav.currentRoom = selectedRoom;
                    streetViewNav.isTransitioning = false;
                    updateInfoPanel(selectedRoom);
                    console.log('âœ… å·²é€²å…¥æˆ¿é–“:', selectedRoom.name);
                }
            }

            transitionToRoomFrame();
        }

        // é»æ“Šåœ°é¢å°èˆªå‡½æ•¸ï¼ˆGoogle Mapsè¡—æ™¯é¢¨æ ¼ï¼‰
        function navigateToPoint(targetPoint) {
            if (streetViewNav.isTransitioning) return;

            // ä¿æŒç›¸åŒçš„Yåº§æ¨™ï¼ˆæ¨“å±¤é«˜åº¦ï¼‰
            const startPos = fpsCamera.position.clone();
            const endPos = new THREE.Vector3(targetPoint.x, startPos.y, targetPoint.z);

            // åŸºæœ¬ç¢°æ’æª¢æ¸¬ï¼šæª¢æŸ¥ç›®æ¨™é»æ˜¯å¦åœ¨æˆ¿é–“å…§
            const buildingGroup = scene.children[4];
            if (buildingGroup) {
                raycaster.setFromCamera(new THREE.Vector2(0, 0), fpsCamera);
                const intersects = raycaster.intersectObjects(buildingGroup.children, true);

                // æª¢æŸ¥æ˜¯å¦é»æ“Šäº†ç‰†é«”æˆ–æˆ¿é–“é‚Šç•Œï¼Œå¦‚æœæ˜¯å‰‡å¾®èª¿ç›®æ¨™ä½ç½®
                for (let intersect of intersects) {
                    if (intersect.object.userData && intersect.object.userData.id) {
                        // ç¢ºä¿ä¸èµ°å…¥æˆ¿é–“ç‰†é«”ï¼Œå‘å¾Œé€€ä¸€é»
                        const direction = endPos.clone().sub(startPos).normalize();
                        endPos.copy(endPos.sub(direction.multiplyScalar(0.5)));
                        break;
                    }
                }
            }

            // è¨ˆç®—è·é›¢ä»¥æ±ºå®šè½‰ç§»æ™‚é–“ï¼ˆæ›´é çš„è·é›¢ = æ›´é•·çš„æ™‚é–“ï¼‰
            const distance = startPos.distanceTo(endPos);
            const duration = Math.max(0.5, Math.min(distance / 5, 5));  // 0.5-5ç§’ï¼Œå¢åŠ æœ€å¤§æ™‚é–“

            streetViewNav.isTransitioning = true;
            let elapsed = 0;

            function transitionToPointFrame() {
                elapsed += 0.016;
                const progress = Math.min(elapsed / duration, 1);

                // ä½¿ç”¨ç·©å‹•å‡½æ•¸ä½¿é‹å‹•æ›´è‡ªç„¶
                const easeProgress = progress < 0.5
                    ? 2 * progress * progress
                    : -1 + (4 - 2 * progress) * progress;

                fpsCamera.position.lerpVectors(startPos, endPos, easeProgress);

                // ç›¸æ©Ÿçœ‹å‘ç›®æ¨™æ–¹å‘
                const direction = endPos.clone().sub(startPos).normalize();
                const lookAtPoint = fpsCamera.position.clone().add(direction);
                fpsCamera.lookAt(lookAtPoint);

                if (progress < 1) {
                    requestAnimationFrame(transitionToPointFrame);
                } else {
                    fpsCamera.position.copy(endPos);
                    streetViewNav.isTransitioning = false;
                    console.log('âœ… å·²å°èˆªåˆ°ä½ç½®:', {x: endPos.x.toFixed(2), z: endPos.z.toFixed(2)});
                }
            }

            transitionToPointFrame();
        }

        // Minecraft é¢¨æ ¼çš„ç›¸æ©Ÿæ§åˆ¶
        const minecraftControls = {
            pitch: 0,           // ä¸Šä¸‹çœ‹ï¼ˆ-Ï€/2 åˆ° Ï€/2ï¼‰
            yaw: 0,             // å·¦å³çœ‹
            mouseSensitivity: 0.003,  // é¼ æ¨™éˆæ•åº¦
            isDragging: false,
            lastX: 0,
            lastY: 0
        };
        window.minecraftControls = minecraftControls;  // æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸ

        // ==================== æˆ¿é–“é‚Šç•Œç´„æŸå‡½æ•¸ ====================
        /**
         * é©—è­‰ä¸¦ç´„æŸæˆ¿é–“ä½ç½®åœ¨å»ºç¯‰é‚Šç•Œå…§
         * å»ºç¯‰ä¸­å¿ƒåœ¨ (0,0)ï¼Œå¯¬åº¦32 (-16åˆ°16)ï¼Œæ·±åº¦20 (-10åˆ°10)
         */
        function constrainRoomToBounds(room) {
            const buildingHalfWidth = BUILDING_CONFIG.width / 2;   // 16
            const buildingHalfDepth = BUILDING_CONFIG.depth / 2;   // 10

            // è¨ˆç®—æˆ¿é–“é‚Šç•Œ
            const roomLeft = room.x - room.w / 2;
            const roomRight = room.x + room.w / 2;
            const roomFront = room.z - room.d / 2;
            const roomBack = room.z + room.d / 2;

            // æª¢æŸ¥ä¸¦è¨˜éŒ„é•å
            const violations = [];
            if (roomLeft < -buildingHalfWidth) violations.push(`LEFT(${roomLeft.toFixed(1)}<-16)`);
            if (roomRight > buildingHalfWidth) violations.push(`RIGHT(${roomRight.toFixed(1)}>16)`);
            if (roomFront < -buildingHalfDepth) violations.push(`FRONT(${roomFront.toFixed(1)}<-10)`);
            if (roomBack > buildingHalfDepth) violations.push(`BACK(${roomBack.toFixed(1)}>10)`);

            // ç´„æŸé‚Šç•Œï¼šç¢ºä¿æˆ¿é–“å®Œå…¨åœ¨å»ºç¯‰å…§
            let constrainedX = room.x;
            let constrainedZ = room.z;

            // Xè»¸ç´„æŸï¼ˆå·¦å³ï¼‰
            const minX = -buildingHalfWidth + room.w / 2;
            const maxX = buildingHalfWidth - room.w / 2;
            constrainedX = Math.max(minX, Math.min(maxX, room.x));

            // Zè»¸ç´„æŸï¼ˆå‰å¾Œï¼‰
            const minZ = -buildingHalfDepth + room.d / 2;
            const maxZ = buildingHalfDepth - room.d / 2;
            constrainedZ = Math.max(minZ, Math.min(maxZ, room.z));

            // å¦‚æœæœ‰ç´„æŸï¼Œè¨˜éŒ„èª¿æ•´
            if (constrainedX !== room.x || constrainedZ !== room.z) {
                console.warn(`ğŸ”§ æˆ¿é–“ç´„æŸ: ${room.id} (${room.name}) [${violations.join(', ')}]`);
                console.log(`   åŸå§‹: (${room.x.toFixed(1)}, ${room.z.toFixed(1)}) â†’ èª¿æ•´: (${constrainedX.toFixed(1)}, ${constrainedZ.toFixed(1)})`);

                // æ‡‰ç”¨ç´„æŸ
                room.x = constrainedX;
                room.z = constrainedZ;
            }

            return violations.length > 0;
        }

        /**
         * é©—è­‰æ‰€æœ‰æˆ¿é–“ä¸¦å ±å‘Šçµ±è¨ˆ
         */
        function validateAllRoomBounds() {
            let totalViolations = 0;
            let violatingRooms = [];

            // éæ­·æ‰€æœ‰æ¨“å±¤çš„æ‰€æœ‰æˆ¿é–“
            Object.keys(ROOM_DATA).forEach(floor => {
                const rooms = ROOM_DATA[floor] || [];
                rooms.forEach(room => {
                    const hasViolation = constrainRoomToBounds(room);
                    if (hasViolation) {
                        totalViolations++;
                        violatingRooms.push(`${room.id}(${room.name})`);
                    }
                });
            });

            // å ±å‘Šçµ±è¨ˆ
            if (totalViolations > 0) {
                console.warn(`âš ï¸ æˆ¿é–“é‚Šç•Œé©—è­‰: ç™¼ç¾ ${totalViolations} å€‹æˆ¿é–“è¶…å‡ºé‚Šç•Œ`);
                console.warn(`   å—å½±éŸ¿æˆ¿é–“: ${violatingRooms.join(', ')}`);
            } else {
                console.log('âœ… æ‰€æœ‰æˆ¿é–“éƒ½åœ¨å»ºç¯‰é‚Šç•Œå…§');
            }

            return totalViolations;
        }

        // ==================== æˆ¿é–“æ•¸æ“š (ä¿®å¾©ç‰ˆæœ¬ v4.0 - é›¶é‡ç–Šé…ç½®) ====================
        const ROOM_DATA = {
            'B1': [
                // ä¿®å¾©: åœè»Šå ´ç¸®æ¸›ï¼ŒæŠ€è¡“å®¤å—å´æ’åˆ—ï¼ˆå®Œå…¨åˆ†é›¢ï¼‰
                { id: 'B1-01', name: 'åœè»Šå ´', x: 0, z: 3, w: 28, d: 10, area: 280, type: 'facility', equipment: ['åœè»Šä½Ã—60', 'æ„Ÿæ¸¬ç³»çµ±'] },
                { id: 'B1-02', name: 'ç©ºèª¿æ©Ÿæˆ¿', x: 13, z: -8.5, w: 3, d: 3, area: 9, type: 'technical', equipment: ['å†·æš–ä¸»æ©ŸÃ—2'] },
                { id: 'B1-03', name: 'é…é›»å®¤', x: 10, z: -8.5, w: 3, d: 3, area: 9, type: 'technical', equipment: ['ä¸»é…ç›¤', 'UPSç³»çµ±'] },
                { id: 'B1-04', name: 'çµ¦æ’æ°´', x: 7, z: -8.5, w: 2, d: 2, area: 4, type: 'technical', equipment: ['æ°´å¡”Ã—1'] },
                { id: 'B1-05', name: 'é›¨æ°´å›æ”¶', x: 4, z: -8.5, w: 2, d: 2, area: 4, type: 'technical', equipment: ['å„²å­˜æ± '] }
            ],
            '1F': [
                // ä¿®å¾©: 1F = å¤±æ™ºå°ˆå€(è¥¿) + ä¸€èˆ¬æ—¥ç…§å€(æ±) + å…±äº«ç©ºé–“(åŒ—)  - å®Œå…¨åˆ†é›¢
                { id: '1F-01', name: 'å¤±æ™ºç—‡å°ˆå€', x: -9, z: -2, w: 12, d: 13, area: 156, type: 'healthcare', equipment: ['æ„Ÿæ¸¬è¨­å‚™', 'äº’å‹•æŠ•å½±', 'æ´»å‹•å®¤', 'ç„¡éšœç¤™è¡›æµ´'], subzones: ['æ„Ÿæ¸¬å€', 'æŠ•å½±å€', 'æ´»å‹•å®¤', 'è¡›æµ´'] },
                { id: '1F-02', name: 'ä¸€èˆ¬æ—¥ç…§å€', x: 7, z: -3, w: 12, d: 14, area: 168, type: 'healthcare', equipment: ['å¾©å¥å™¨æ', 'è—è¡“ç¾è¡“', 'èªçŸ¥è¨“ç·´'], subzones: ['å¾©å¥è¨“ç·´', 'è—è¡“ç™‚æ³•', 'èªçŸ¥è¨“ç·´'] },
                { id: '1F-03', name: 'å…±äº«ç©ºé–“', x: 0, z: 8, w: 18, d: 4, area: 72, type: 'dining', equipment: ['é¤å»³Ã—120äºº', 'å»šæˆ¿è¨­å‚™', 'è­·ç†ç«™ç›£æ§'], subzones: ['ç”¨é¤å€', 'å»šæˆ¿', 'è­·ç†ç«™'] }
            ],
            '2F': [
                // ä¿®å¾©: 2F = å¬°å…’æ•™å®¤(è¥¿åŒ—) + å¹¼å…’æ•™å®¤(æ±åŒ—) + å‰¯é£Ÿå“å®¤(è¥¿ä¸­å—) + ç¡çœ å®¤(æ±ä¸­å—) + è¦ªå­å…±è®€å€(è¥¿å—) + æ”¯æ´è¨­æ–½(æ±å—) - å®Œå…¨åˆ†é›¢
                { id: '2F-01', name: '0-2æ­²å¬°å…’æ•™å®¤', x: -8, z: 4, w: 12, d: 10, area: 120, type: 'healthcare', equipment: ['SIDSç›£æ¸¬Ã—50', 'å¬°å…’åºŠÃ—50', 'çˆ¬è¡Œå¢Š', 'ç©å…·æ¶', 'é¤µé£Ÿå°', 'è¡›æµ´è¨­æ–½'], subzones: ['ç¡çœ å€', 'æ´»å‹•å€', 'é¤µé£Ÿå€', 'è¡›æµ´'] },
                { id: '2F-02', name: '2-3æ­²å¹¼å…’æ•™å®¤', x: 8, z: 4, w: 12, d: 9, area: 108, type: 'activity', equipment: ['æ”€çˆ¬æ¶', 'æ»‘æ¢¯', 'çƒæ± ', 'æ•…äº‹æŠ•å½±', 'åˆç¡åºŠÃ—15', 'è‡ªç†è¨“ç·´å°'], subzones: ['éŠæˆ²å€', 'æ•…äº‹æ™‚é–“', 'ä¸»é¡Œæ´»å‹•', 'åˆç¡å€', 'è‡ªç†è¨“ç·´'] },
                { id: '2F-03', name: 'å‰¯é£Ÿå“æº–å‚™å®¤', x: -8, z: -8.5, w: 8, d: 3, area: 24, type: 'facility', equipment: ['çƒ¹é£ªå°', 'å†°ç®±', 'æ¶ˆæ¯’æ«ƒ', 'å·¥ä½œå°'], subzones: ['çƒ¹å»šå€', 'æ¶ˆæ¯’å€'] },
                { id: '2F-04', name: 'ç¡çœ å®¤', x: 5, z: -8.5, w: 8, d: 3, area: 24, type: 'healthcare', equipment: ['å¬°å…’åºŠÃ—12', 'æ†æº«æ¿•åº¦æ§åˆ¶', 'éœéŸ³éŸ³æ¨‚ç³»çµ±'], subzones: ['ç¡çœ å€'] },
                { id: '2F-05', name: 'è¦ªå­å…±è®€å€', x: -8, z: -4, w: 10, d: 6, area: 60, type: 'education', equipment: ['æ›¸æ¶Ã—3', 'èˆ’é©åº§ä½Ã—8', 'è»Ÿå¢ŠÃ—6'], subzones: ['é–±è®€å€', 'è»Ÿå¢Šå€'] },
                { id: '2F-06', name: 'æ”¯æ´è¨­æ–½', x: 8, z: -4, w: 10, d: 6, area: 60, type: 'facility', equipment: ['ä¸­å¤®ç›£æ§ç³»çµ±', 'æ¶ˆæ¯’å®¤', 'å„²è—å®¤'], subzones: ['ç›£æ§å€', 'æ¶ˆæ¯’å€', 'å„²è—'] }
            ],
            '3F': [
                // ä¿®å¾©: 3Fæ´»å‹•å®¤åˆ†æ•£æ’åˆ— (åŒ—ã€åŒ—ä¸­ã€åŒ—æ±) + è­·ç†ç”¨é¤å€å—æ’åˆ— + è·¨ä»£äº’å‹•ä¸­å¤® - å®Œå…¨åˆ†é›¢
                { id: '3F-01', name: 'æ£‹ç‰Œæ´»å‹•å®¤', x: -11, z: 3, w: 10, d: 7, area: 70, type: 'activity', equipment: ['æ£‹ç‰Œæ¡ŒÃ—8', 'åº§ä½Ã—32', 'è±¡æ£‹', 'éº»å°‡', 'æ’²å…‹ç‰Œçµ„'], subzones: ['æ£‹ç‰Œå€'] },
                { id: '3F-02', name: 'æ‰‹å·¥è—æ´»å‹•å®¤', x: -1, z: 3, w: 10, d: 7, area: 70, type: 'activity', equipment: ['å·¥ä½œå°Ã—4', 'æ‰‹å·¥è—å·¥å…·', 'ææ–™å„²å­˜', 'å±•ç¤ºæ¶'], subzones: ['å·¥ä½œå€', 'å±•ç¤ºå€'] },
                { id: '3F-03', name: 'å¾©å¥æ´»å‹•å®¤', x: 9, z: 3, w: 10, d: 7, area: 70, type: 'activity', equipment: ['å¾©å¥è¨­å‚™', 'ç‘œçˆå¢ŠÃ—15', 'æ‹‰ç­‹ç‰†', 'å¹³è¡¡è¨“ç·´å™¨'], subzones: ['å¾©å¥å€', 'ç‘œçˆå€'] },
                { id: '3F-04', name: 'ç”¨é¤å€', x: -11, z: -8.5, w: 10, d: 3, area: 30, type: 'dining', equipment: ['åœ“å½¢é¤æ¡ŒÃ—8', 'åº§ä½Ã—32', 'é¤å…·æœå‹™å°'], subzones: ['é¤é£²å€'] },
                { id: '3F-05', name: 'è­·ç†å®¤', x: -1, z: -8.5, w: 10, d: 3, area: 30, type: 'healthcare', equipment: ['æª¢æŸ¥åºŠÃ—2', 'é†«ç™‚è¨­å‚™', 'è—¥ç‰©æ«ƒ', 'è¼ªæ¤…Ã—2'], subzones: ['è­·ç†å€', 'ç”¨è—¥å€'] },
                { id: '3F-06', name: 'å¤±æ™ºå‹å–„å®¤', x: 9, z: -8.5, w: 10, d: 3, area: 30, type: 'healthcare', equipment: ['å®¶å±…å®¶å…·', 'è¨˜æ†¶ç‰©å“å±•ç¤º', 'å®‰å…¨æ‰¶æ‰‹Ã—3'], subzones: ['å®¢å»³å€', 'è¨˜æ†¶å€'] },
                { id: '3F-07', name: 'è·¨ä»£äº’å‹•å®¤', x: 0, z: -3, w: 11, d: 4.5, area: 49.5, type: 'education', equipment: ['å·¥ä½œå°Ã—3', 'åº§ä½Ã—12', 'è—è¡“ç”¨å“'], subzones: ['äº’å‹•å€'] }
            ],
            '4F': [
                // ä¿®å¾©è‡»å®Œç‰ˆ: 4Fæ ¸å¿ƒå„ªåŒ– = åŒ—è¥¿(STEM) + åŒ—æ±(æŠ•å½±) + æ±åŒ—(é•·è¼©) + ä¸­å¤®ä¸‹ç§»(é’å°‘å¹´äº¤èª¼å»³) + å—å€å®Œå…¨åˆ†é›¢(æ–‡å‰µ|èª²è¼”|è·æ¶¯|ä¼‘é–’)
                { id: '4F-01', name: 'STEMæ•™å®¤', x: -10, z: 4.5, w: 9, d: 5, area: 45, type: 'education', equipment: ['é›»è…¦Ã—15', 'ArduinoÃ—10', 'Raspberry PiÃ—10', '3Dåˆ—å°æ©ŸÃ—2', 'æ©Ÿå™¨äººå¥—ä»¶Ã—10'], subzones: ['é›»è…¦æ•™å®¤', 'æ©Ÿå™¨äººå€', 'é›»å­å·¥ä½œå°', '3Dåˆ—å°å€'] },
                { id: '4F-02', name: 'æŠ•å½±èˆ‡å±•ç¤ºå€', x: 9, z: 2, w: 9, d: 4, area: 36, type: 'technology', equipment: ['æŠ•å½±æ©ŸÃ—8', 'VRé ­ç›”Ã—10', 'ç·¨è¼¯å·¥ä½œç«™Ã—4', '4Kæ”å½±æ£šèƒŒæ™¯', 'ç¶ å¹•ç³»çµ±'], subzones: ['4KæŠ•å½±å€', 'VRé«”é©—å€', 'éŒ„è£½ç·¨è¼¯å®¤'] },
                { id: '4F-03', name: 'è·æ¶¯ç™¼å±•å€', x: 7, z: -8.5, w: 6, d: 2, area: 12, type: 'education', equipment: ['å°å¸«åº§ä½Ã—3', 'è¦–è¨Šæœƒè­°ç³»çµ±', 'å±¥æ­·æª”æ¡ˆå€', 'è·æ¥­æ¨¡æ“¬å·¥ä½œç«™'], subzones: ['å°å¸«åº§ä½', 'é è·é€£ç·š', 'æ¨¡æ“¬å·¥ä½œå®¤'] },
                { id: '4F-04', name: 'æ–‡å‰µå·¥åŠ', x: -11, z: -7.5, w: 8, d: 3, area: 24, type: 'activity', equipment: ['çƒ˜ç„™å€', 'æ‰‹å·¥è—å°Ã—4', 'ææ–™å„²å­˜', 'å±•ç¤ºæ¶Ã—3'], subzones: ['çƒ˜ç„™å€', 'æ‰‹å·¥è—å€', 'å±•ç¤ºå€'] },
                { id: '4F-05', name: 'èª²è¼”è‡ªç¿’å€', x: -1, z: -7.5, w: 8, d: 3, area: 24, type: 'education', equipment: ['èª²æ¡ŒÃ—30', 'è¨è«–å°çµ„åœ“æ¡ŒÃ—6', 'è¬›å¸«å°'], subzones: ['è‡ªç¿’å€', 'è¨è«–çµ„', 'è¬›å¸«å€'] },
                { id: '4F-06', name: 'ä¼‘é–’å¨›æ¨‚å€', x: 13, z: -6, w: 8, d: 2, area: 16, type: 'activity', equipment: ['é›»ç«¶éŠæˆ²æ©ŸÃ—3', 'ç±ƒçƒæ©Ÿ', 'å¥èº«å™¨æÃ—5'], subzones: ['éŠæˆ²å€', 'é‹å‹•å€'] },
                { id: '4F-07', name: 'é’å°‘å¹´äº¤èª¼å»³', x: 0, z: -2, w: 11, d: 3.5, area: 38.5, type: 'activity', equipment: ['æ²™ç™¼å€', 'èŒ¶å‡ Ã—4', 'è¼•é£Ÿå°', 'é›»è¦–ç‰†'], subzones: ['ä¼‘é–’å€', 'ç”¨é¤å€'] },
                { id: '4F-08', name: 'é•·è¼©åˆ†äº«å®¤', x: 0, z: 8.5, w: 10, d: 2, area: 20, type: 'education', equipment: ['åº§ä½Ã—12', 'å±•ç¤ºæ¶Ã—2', 'éŸ³æ¨‚æ’­æ”¾ç³»çµ±'], subzones: ['åº§ä½å€', 'å±•ç¤ºå€'] }
            ],
            '5F': [
                // ä¿®å¾©: 5F = å¤§æœƒå ‚(ç¸®æ¸›) + å·¥ä½œåŠå®¤(è¥¿å—è§’) + è­°äº‹å®¤(æ±å—è§’)
                { id: '5F-01', name: 'å¤§æœƒå ‚', x: 0, z: 2, w: 26, d: 12, area: 312, type: 'facility', equipment: ['åº§ä½Ã—250', 'è¬›å°', 'æŠ•å½±å¹•'], subzones: ['åº§ä½å€', 'è¬›å°', 'æŠ•å½±å€'] },
                { id: '5F-02', name: 'å·¥ä½œåŠå®¤', x: -12, z: -8.5, w: 8, d: 3, area: 24, type: 'education', equipment: ['å·¥ä½œå°Ã—4', 'ç·´ç¿’å€'], subzones: ['å·¥ä½œå°', 'ç·´ç¿’å€'] },
                { id: '5F-03', name: 'è­°äº‹å®¤', x: 12, z: -8.5, w: 8, d: 3, area: 24, type: 'administrative', equipment: ['æœƒè­°æ¡Œ', 'åº§ä½Ã—16', 'æª”æ¡ˆæ«ƒ'], subzones: ['æœƒè­°å€', 'æª”æ¡ˆå€'] }
            ],
            '6F': [
                // 6Fç„¡ä¿®æ”¹ - å·²ç¶“é…ç½®æ­£ç¢º
                { id: '6F-01', name: 'ä¼æ¥­å±•ç¤ºå»³', x: 0, z: 2, w: 24, d: 10, area: 240, type: 'facility', equipment: ['å±•ç¤ºæ«ƒÃ—8', 'äº’å‹•è¢å¹•'], subzones: ['å±•ç¤ºå€', 'äº’å‹•å€'] },
                { id: '6F-02', name: 'æ¥­å¸«è¾¦å…¬å®¤', x: -8, z: -8, w: 12, d: 6, area: 72, type: 'administrative', equipment: ['è¾¦å…¬æ¡ŒÃ—4', 'æœƒè­°å°å°'], subzones: ['è¾¦å…¬å€', 'æœƒè­°å€'] },
                { id: '6F-03', name: 'æœƒè­°å®¤', x: 12, z: -8, w: 10, d: 6, area: 60, type: 'administrative', equipment: ['æœƒè­°æ¡Œ', 'åº§ä½Ã—12', 'æŠ•å½±è¢å¹•'], subzones: ['æœƒè­°å€', 'æŠ•å½±å€'] }
            ],
            '7F': [
                // ä¿®å¾©: 7Få±‹é ‚èŠ±åœ’èª¿æ•´ç‚ºä¸è¶…é‚Šç•Œä¸¦å®Œå…¨åˆ†é›¢
                { id: '7F-01', name: 'å±‹é ‚è¾²å ´', x: -7, z: -2, w: 11, d: 9, area: 99, type: 'facility', equipment: ['ç¨®æ¤åºŠÃ—8', 'æ¾†æ°´ç³»çµ±', 'ä¼‘æ†©åº§ä½'], subzones: ['ç¨®æ¤å€', 'ä¼‘æ¯å€'] },
                { id: '7F-02', name: 'å¤ªé™½èƒ½å€', x: 7, z: -2, w: 11, d: 9, area: 99, type: 'technical', equipment: ['å¤ªé™½èƒ½æ¿Ã—6', 'ç™¼é›»è¨­å‚™', 'ç›£æ§ç³»çµ±'], subzones: ['å¤ªé™½èƒ½æ¿', 'è¨­å‚™å€'] },
                { id: '7F-03', name: 'éœ²å°å€', x: 0, z: 7.5, w: 14, d: 5, area: 70, type: 'activity', equipment: ['æ™¯è§€æ¤…', 'æ¤ç‰©ç›†æ ½'], subzones: ['æ™¯è§€æ¤…', 'æ¤ç‰©å€'] }
            ]
        };

        // ==================== Three.js å ´æ™¯ ====================
        let scene, renderer;
        let building;
        let frameCount = 0, lastTime = Date.now(), fps = 0;
        let raycaster, velocity;

        // ç¢ºä¿ Three.js å·²åŠ è¼‰
        function checkThreeJS() {
            if (typeof THREE === 'undefined') {
                console.error('âŒ Three.js å°šæœªåŠ è¼‰');
                setTimeout(checkThreeJS, 100);
                return false;
            }
            console.log('âœ… Three.js å·²åŠ è¼‰');
            raycaster = new THREE.Raycaster();
            velocity = new THREE.Vector3();
            return true;
        }

        function initThreeJS() {
            const container = document.getElementById('canvas-container');

            // å ´æ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e27);
            scene.fog = new THREE.Fog(0x0a0e27, 100, 500);

            // å¤–éƒ¨è¦–è§’ç›¸æ©Ÿï¼ˆè»Œé“æ§åˆ¶ï¼‰
            orbitCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            orbitCamera.position.set(80, 60, 80);

            // ç¬¬ä¸€äººç¨±è¦–è§’ç›¸æ©Ÿï¼ˆFPSï¼‰- èª¿æ•´è¿‘/é å¹³é¢ä»¥é˜²æ­¢ç¢°æ’æ™‚è£å‰ª
            fpsCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.05, 1000);
            fpsCamera.position.set(0, FPS_HEIGHT, 0);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // è»Œé“æ§åˆ¶å™¨ï¼ˆå¤–éƒ¨è¦–è§’ï¼‰
            orbitControls = new window.OrbitControls(orbitCamera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.autoRotate = true;
            orbitControls.autoRotateSpeed = 2;

            // FPS æ§åˆ¶å™¨ï¼ˆç¬¬ä¸€äººç¨±ï¼‰
            pointerLockControls = new window.PointerLockControls(fpsCamera, renderer.domElement);
            scene.add(pointerLockControls.getObject());

            // å…‰ç…§
            setupLighting();

            // å»ºç¯‰
            building = createBuilding();
            scene.add(building);

            // åœ°é¢
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x1a3a2a, side: THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            ground.receiveShadow = true;
            scene.add(ground);

            // éµç›¤äº‹ä»¶ç›£è½
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            // Minecraft é¢¨æ ¼çš„é¼ æ¨™ç§»å‹•ç›£è½ï¼ˆç”¨æ–¼ç›¸æ©Ÿæ—‹è½‰ï¼‰
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mousedown', () => {
                minecraftControls.isDragging = true;
                renderer.domElement.style.cursor = 'grabbing';
            });
            renderer.domElement.addEventListener('mouseup', () => {
                minecraftControls.isDragging = false;
                renderer.domElement.style.cursor = 'default';
            });

            // Pointer Lock å’Œè¡—æ™¯å°èˆªé»æ“Šäº‹ä»¶
            renderer.domElement.addEventListener('click', (event) => {
                // FPSæ¨¡å¼ä¸‹çš„é»æ“Šå°èˆªï¼ˆé¡ä¼¼Google Mapsè¡—æ™¯ï¼‰
                if (currentMode === 'fps') {
                    const mouse = new THREE.Vector2();
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                    raycaster.setFromCamera(mouse, fpsCamera);

                    // 1. é¦–å…ˆæª¢æ¸¬æ˜¯å¦é»æ“Šäº†å°èˆªæ¨™è¨˜
                    if (streetViewNav.navigationMarkers.length > 0) {
                        const markerIntersects = raycaster.intersectObjects(streetViewNav.navigationMarkers);
                        if (markerIntersects.length > 0) {
                            const marker = markerIntersects[0].object;
                            if (marker.userData && marker.userData.waypoint) {
                                moveToWaypoint(marker.userData.waypoint);
                                return;
                            }
                        }
                    }

                    // 2. æª¢æ¸¬æ˜¯å¦é»æ“Šäº†æˆ¿é–“é€²å…¥é»
                    const allObjects = scene.children.flatMap(child => {
                        if (child.children && child.children.length > 0) {
                            return child.children;
                        }
                        return child;
                    });

                    const intersects = raycaster.intersectObjects(allObjects);

                    for (let i = 0; i < intersects.length; i++) {
                        const intersect = intersects[i];

                        // æª¢æ¸¬æ˜¯å¦é»æ“Šäº†æˆ¿é–“é‚Šç•Œæˆ–æ¨™ç±¤
                        if (intersect.object.userData && intersect.object.userData.id) {
                            const roomId = intersect.object.userData.id;
                            enterRoom(roomId);
                            return;
                        }
                    }

                    // 3. å¦‚æœé»æ“Šäº†åœ°é¢ï¼Œå°èˆªåˆ°è©²ä½ç½®ï¼ˆåœ°é¢å°èˆªï¼‰
                    const groundIntersects = raycaster.intersectObject(scene, true);
                    if (groundIntersects.length > 0) {
                        // æŸ¥æ‰¾åœ°é¢ï¼ˆé€šå¸¸æ˜¯æœ€å¾Œä¸€å€‹å­å…ƒç´ ï¼‰
                        for (let i = groundIntersects.length - 1; i >= 0; i--) {
                            const intersect = groundIntersects[i];
                            // æª¢æŸ¥æ˜¯å¦æ˜¯åœ°é¢ï¼ˆYåº§æ¨™æ¥è¿‘æ¨“å±¤é«˜åº¦ï¼‰
                            if (intersect.point && Math.abs(intersect.point.y - (fpsCamera.position.y - 1.6)) < 1) {
                                // å°èˆªåˆ°é»æ“Šä½ç½®
                                navigateToPoint(intersect.point);
                                return;
                            }
                        }
                    }
                }
            });

            // èª¿æ•´çª—å£å¤§å°
            window.addEventListener('resize', onWindowResize);

            // æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œè®“æ¸¬è©¦å’Œå°èˆªåŠŸèƒ½å¯ä»¥è¨ªå•
            window.scene = scene;
            window.renderer = renderer;
            window.camera = orbitCamera;  // é»˜èªç›¸æ©ŸæŒ‡å‘è»Œé“ç›¸æ©Ÿ
            window.orbitCamera = orbitCamera;
            window.fpsCamera = fpsCamera;
            window.orbitControls = orbitControls;
            window.pointerLockControls = pointerLockControls;
            window.raycaster = raycaster;

            console.log('âœ… å ´æ™¯å·²åˆå§‹åŒ– (Scene objects: ' + scene.children.length + ')');

            // å‹•ç•«å¾ªç’°
            animate();
        }

        function setupLighting() {
            // ç’°å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            // å¤ªé™½å…‰
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(100, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            scene.add(sunLight);

            // åŠçƒå…‰
            const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x2d5016, 0.3);
            scene.add(hemiLight);
        }

        // æ·»åŠ æˆ¿é–“å®¶å…·å’Œè¨­å‚™ - Stage 4 å°ˆæ¥­è¨­è¨ˆå¯¦ç¾
        function addFurnitureToRoom(group, room, yOffset, floorHeight, roomColor) {
            const furnitureGroup = new THREE.Group();

            // æ ¹æ“šæ¨“å±¤å’Œæˆ¿é–“IDé€²è¡ŒStage 4ç²¾ç¢ºè¨­è¨ˆ
            const floorKey = Object.keys(ROOM_DATA).find(key =>
                ROOM_DATA[key].some(r => r.id === room.id)
            );

            switch(floorKey) {
                case 'B1':
                    // åœ°ä¸‹1å±¤ï¼šåœè»Šå ´ + æ©Ÿæˆ¿
                    if (room.name.includes('åœè»Š')) {
                        addParking(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('æ©Ÿæˆ¿')) {
                        addMechanicalRoom(furnitureGroup, room, yOffset, floorHeight);
                    }
                    break;

                case '1F':
                    // 1æ¨“ï¼šæ¥é€å€ã€æ™‚é–“éŠ€è¡Œã€è¡Œæ”¿æœå‹™ã€å»šæˆ¿ã€é†«ç™‚å®¤
                    if (room.name.includes('æ¥é€')) {
                        addPickupArea(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('æ™‚é–“éŠ€è¡Œ')) {
                        addTimeBank(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('å»šæˆ¿')) {
                        addCommunityKitchen(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('é†«ç™‚')) {
                        addEmergencyMedical(furnitureGroup, room, yOffset, floorHeight);
                    }
                    break;

                case '2F':
                    // 2æ¨“ï¼šå…¬å…±æ‰˜å¬°ä¸­å¿ƒ (Stage 4: 0-2æ­²æ•™å®¤ã€2-3æ­²æ•™å®¤ã€å‰¯é£Ÿå“ã€ç¡çœ å®¤ã€è¦ªå­å…±è®€ã€æ”¯æ´è¨­æ–½) âœ…CORRECTED
                    if (room.name.includes('0-2')) {
                        addInfantClassroom(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('2-3')) {
                        addToddlerClassroom(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('ç¡çœ ')) {
                        addNapRoom(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('å‰¯é£Ÿå“')) {
                        addFoodPrep(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('å…±è®€')) {
                        addParentChildReadingArea(furnitureGroup, room, yOffset, floorHeight);
                    }
                    break;

                case '3F':
                    // 3æ¨“ï¼šé•·ç…§æ—¥ç…§ä¸­å¿ƒ (Stage 4: æ´»å‹•å®¤A/Bã€ç”¨é¤ã€è­·ç†å®¤ã€å¤±æ™ºå±…å®¶å®¤ã€è·¨ä»£å®¤) âœ…CORRECTED
                    if (room.name.includes('æ£‹ç‰Œ')) {
                        addActivityRoom(furnitureGroup, room, yOffset, floorHeight, room.name);
                    } else if (room.name.includes('æ‰‹å·¥')) {
                        addActivityRoom(furnitureGroup, room, yOffset, floorHeight, room.name);
                    } else if (room.name.includes('å¾©å¥')) {
                        addActivityRoom(furnitureGroup, room, yOffset, floorHeight, room.name);
                    } else if (room.name.includes('ç”¨é¤')) {
                        addLongTermCareDining(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('è­·ç†')) {
                        addNursingRoom(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('å¤±æ™º')) {
                        addDementiaFriendlyRoom(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('è·¨ä»£')) {
                        addIntergenerationalRoom(furnitureGroup, room, yOffset, floorHeight);
                    }
                    break;

                case '4F':
                    // 4æ¨“ï¼šé’å°‘å¹´æ´»å‹•ä¸­å¿ƒ (Stage 4: STEMæ•™å®¤ã€æŠ•å½±èˆ‡å±•ç¤ºå€ã€è·æ¶¯ç™¼å±•å€ã€æ–‡å‰µå·¥åŠã€èª²è¼”è‡ªç¿’ã€ä¼‘é–’å¨›æ¨‚ã€äº¤èª¼å»³ã€é•·è¼©åˆ†äº«å®¤)
                    if (room.name.includes('STEM')) {
                        addSTEMClassroom(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('æŠ•å½±èˆ‡å±•ç¤º')) {
                        addProjectionShowroom(furnitureGroup, room, yOffset, floorHeight);  // ğŸ¬ VR + ç·¨è¼¯å·¥ä½œç«™
                    } else if (room.name.includes('è·æ¶¯')) {
                        addCareerDevelopmentArea(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('æ–‡å‰µ')) {
                        addCreativeWorkshop(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('èª²è¼”')) {
                        addTutoringArea(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('å¨›æ¨‚')) {
                        addRecreationArea(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('äº¤èª¼')) {
                        addYouthLounge(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('é•·è¼©')) {
                        addElderlyShareRoom(furnitureGroup, room, yOffset, floorHeight);
                    }
                    break;

                case '5F':
                    // 5æ¨“ï¼šåƒèˆ‡å¼é ç®— + ç¤¾å€æ²»ç†
                    if (room.name.includes('å¤§æœƒ')) {
                        addCommunityHall(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('å·¥ä½œåŠ')) {
                        addWorkshopRoom(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('è­°äº‹')) {
                        addCivicRoom(furnitureGroup, room, yOffset, floorHeight);
                    }
                    break;

                case '6F':
                    // 6æ¨“ï¼šESGä¼æ¥­å±•ç¤º
                    if (room.name.includes('å±•ç¤º')) {
                        addCorporateShowroom(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('è¾¦å…¬')) {
                        addMentorOffice(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('æœƒè­°')) {
                        addMeetingRoom(furnitureGroup, room, yOffset, floorHeight);
                    }
                    break;

                case '7F':
                    // 7æ¨“ï¼šå±‹é ‚èŠ±åœ’
                    if (room.name.includes('è¾²å ´')) {
                        addRooftopFarm(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('å¤ªé™½èƒ½')) {
                        addSolarPanels(furnitureGroup, room, yOffset, floorHeight);
                    } else if (room.name.includes('éœ²å°')) {
                        addTerraceArea(furnitureGroup, room, yOffset, floorHeight);
                    }
                    break;

                default:
                    // å‚™ç”¨æ–¹æ¡ˆï¼šé€šç”¨å®¶å…·
                    addBasicFurniture(furnitureGroup, room, yOffset, floorHeight);
            }

            // ğŸ”§ FIX: æ¨™è¨˜å®¶å…·ç¾¤çµ„ç‚ºæ¨“å±¤ç‰©é«”ï¼Œä»¥ä¾¿åœ¨åˆ‡æ›æ¨“å±¤æ™‚éš±è—/é¡¯ç¤º
            furnitureGroup.userData = { floor: floorKey };

            group.add(furnitureGroup);
        }

        // æ·»åŠ ç—…åºŠ
        function addHospitalBeds(group, room, yOffset, floorHeight) {
            const bedCount = Math.floor((room.w / 3.5) * (room.d / 2.5));
            const bedGeometry = new THREE.BoxGeometry(2, 0.8, 1.2);
            const bedMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.3, roughness: 0.7 });

            for (let i = 0; i < Math.min(bedCount, 4); i++) {
                const bed = new THREE.Mesh(bedGeometry, bedMaterial);
                const x = room.x - room.w / 2 + 2.5 + (i % 2) * 3.5;
                const z = room.z - room.d / 2 + 1.5 + Math.floor(i / 2) * 2.5;
                bed.position.set(x, yOffset + 0.4, z);
                bed.castShadow = true;
                bed.receiveShadow = true;
                group.add(bed);
            }
        }

        // æ·»åŠ è¼ªæ¤…
        function addWheelchairs(group, room, yOffset, floorHeight) {
            const wheelchairGeometry = new THREE.BoxGeometry(0.6, 1, 1);
            const wheelchairMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.6, roughness: 0.4 });

            for (let i = 0; i < 2; i++) {
                const wheelchair = new THREE.Mesh(wheelchairGeometry, wheelchairMaterial);
                wheelchair.position.set(room.x + (i - 0.5) * 2, yOffset + 0.5, room.z + room.d / 2 - 1);
                wheelchair.castShadow = true;
                wheelchair.receiveShadow = true;
                group.add(wheelchair);
            }
        }

        // æ·»åŠ é†«ç™‚è¨­å‚™
        function addMedicalEquipment(group, room, yOffset, floorHeight) {
            const equipmentGeometry = new THREE.BoxGeometry(0.5, 1.5, 0.4);
            const equipmentMaterial = new THREE.MeshStandardMaterial({ color: 0x4488ff, metalness: 0.4, roughness: 0.6 });

            for (let i = 0; i < 2; i++) {
                const equipment = new THREE.Mesh(equipmentGeometry, equipmentMaterial);
                equipment.position.set(room.x - room.w / 2 + 1.5, yOffset + 0.75, room.z + (i - 0.5) * 2);
                equipment.castShadow = true;
                equipment.receiveShadow = true;
                group.add(equipment);
            }
        }

        // æ·»åŠ æ¤…å­
        function addChairs(group, room, yOffset, floorHeight, count) {
            const chairGeometry = new THREE.BoxGeometry(0.5, 0.9, 0.5);
            const chairMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513, metalness: 0.1, roughness: 0.8 });

            for (let i = 0; i < count; i++) {
                const chair = new THREE.Mesh(chairGeometry, chairMaterial);
                const angle = (i / count) * Math.PI * 2;
                const radius = Math.min(room.w, room.d) / 3;
                const depthOffset = i * 0.001;  // ğŸ”§ FIX: Apply depth offset to Z coordinate to prevent Z-fighting
                chair.position.set(
                    room.x + Math.cos(angle) * radius,
                    yOffset + 0.45,
                    room.z + Math.sin(angle) * radius + depthOffset
                );
                chair.castShadow = true;
                chair.receiveShadow = true;
                group.add(chair);
            }
        }

        // æ·»åŠ æ¡Œå­
        function addTables(group, room, yOffset, floorHeight, count) {
            const tableGeometry = new THREE.BoxGeometry(1.2, 0.75, 0.8);
            const tableMaterial = new THREE.MeshStandardMaterial({ color: 0xc0a080, metalness: 0.2, roughness: 0.7 });

            for (let i = 0; i < count; i++) {
                const table = new THREE.Mesh(tableGeometry, tableMaterial);
                const depthOffset = i * 0.001;  // ğŸ”§ FIX: Apply depth offset to Z coordinate to prevent Z-fighting
                table.position.set(
                    room.x + (i - count / 2 + 0.5) * 2,
                    yOffset + 0.375,
                    room.z + depthOffset
                );
                table.castShadow = true;
                table.receiveShadow = true;
                group.add(table);
            }
        }

        // æ·»åŠ ç”¨é¤æ¡Œ
        function addDiningTables(group, room, yOffset, floorHeight) {
            const tableGeometry = new THREE.BoxGeometry(1.5, 0.75, 1);
            const tableMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513, metalness: 0.2, roughness: 0.7 });

            const tableCount = Math.min(Math.floor((room.w * room.d) / 8), 4);
            for (let i = 0; i < tableCount; i++) {
                const table = new THREE.Mesh(tableGeometry, tableMaterial);
                const x = room.x - room.w / 2 + 2 + (i % 2) * 2.5;
                const z = room.z - room.d / 2 + 1.5 + Math.floor(i / 2) * 2;
                table.position.set(x, yOffset + 0.375, z);
                table.castShadow = true;
                table.receiveShadow = true;
                group.add(table);
            }
        }

        // æ·»åŠ æ´»å‹•è¨­å‚™
        function addActivityEquipment(group, room, yOffset, floorHeight) {
            const equipmentGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.8);
            const equipmentMaterial = new THREE.MeshStandardMaterial({ color: 0xff6b9d, metalness: 0.3, roughness: 0.6 });

            const equipment = new THREE.Mesh(equipmentGeometry, equipmentMaterial);
            equipment.position.set(room.x, yOffset + 0.6, room.z);
            equipment.castShadow = true;
            equipment.receiveShadow = true;
            group.add(equipment);
        }

        // æ·»åŠ ä¼ºæœå™¨æ©Ÿæ«ƒ
        function addServerRacks(group, room, yOffset, floorHeight) {
            const rackGeometry = new THREE.BoxGeometry(0.6, 2, 0.5);
            const rackMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.8, roughness: 0.3 });

            const rackCount = Math.floor((room.w - 1) / 1.5);
            for (let i = 0; i < rackCount; i++) {
                const rack = new THREE.Mesh(rackGeometry, rackMaterial);
                rack.position.set(room.x - room.w / 2 + 1.5 + i * 1.5, yOffset + 1, room.z);
                rack.castShadow = true;
                rack.receiveShadow = true;
                group.add(rack);
            }
        }

        // ========== B1 å±¤ - åœè»Šå ´ & æ©Ÿæˆ¿ ==========
        function addParking(group, room, yOffset, floorHeight) {
            // åœè»Šä½ (80å€‹)ï¼šç°¡åŒ–è¡¨ç¤ºåœè»Šç·šæ¢
            const carSpacing = 2.5;
            const rowSpacing = 5;
            let carIndex = 0;

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 5; col++) {
                    if (carIndex >= 20) break;
                    const x = room.x - room.w / 2 + 1.5 + col * rowSpacing;
                    const z = room.z - room.d / 2 + 2 + row * carSpacing;

                    // ç°¡åŒ–æ±½è»Šæ¨¡å‹
                    const carGeometry = new THREE.BoxGeometry(2, 1.2, 4);
                    const carMaterial = new THREE.MeshStandardMaterial({
                        color: 0xff0000 + Math.random() * 0xffff,
                        metalness: 0.6,
                        roughness: 0.4
                    });
                    const car = new THREE.Mesh(carGeometry, carMaterial);
                    const depthOffset = carIndex * 0.001;  // ğŸ”§ FIX: Apply depth offset to Z coordinate to prevent Z-fighting
                    car.position.set(x, yOffset + 0.6, z + depthOffset);
                    car.castShadow = true;
                    car.receiveShadow = true;
                    group.add(car);
                    carIndex++;
                }
            }
        }

        function addMechanicalRoom(group, room, yOffset, floorHeight) {
            // æ©Ÿæ¢°è¨­å‚™ï¼šHVAC æ©Ÿçµ„ã€æ°´æ³µã€è®Šå£“å™¨ç­‰

            // å¤§å‹æ©Ÿæ¢°è¨­å‚™
            const hvacGeometry = new THREE.BoxGeometry(2, 1.5, 1.5);
            const metalMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.9, roughness: 0.2 });

            const hvac = new THREE.Mesh(hvacGeometry, metalMaterial);
            hvac.position.set(room.x - room.w / 2 + 2, yOffset + 0.75, room.z - room.d / 2 + 2);
            hvac.castShadow = true;
            hvac.receiveShadow = true;
            group.add(hvac);

            // æ°´æ³µ
            const pumpGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 16);
            const pump = new THREE.Mesh(pumpGeometry, metalMaterial);
            pump.position.set(room.x - room.w / 2 + 2, yOffset + 0.75, room.z);
            pump.castShadow = true;
            pump.receiveShadow = true;
            group.add(pump);

            // è®Šå£“å™¨
            const transformerGeometry = new THREE.BoxGeometry(1, 1, 1);
            const transformer = new THREE.Mesh(transformerGeometry, metalMaterial);
            transformer.position.set(room.x - room.w / 2 + 2, yOffset + 0.5, room.z + room.d / 2 - 2);
            transformer.castShadow = true;
            transformer.receiveShadow = true;
            group.add(transformer);
        }

        // ========== 1F å±¤ - æ¥é€å€ã€æ™‚é–“éŠ€è¡Œã€å»šæˆ¿ã€é†«ç™‚å®¤ ==========
        function addPickupArea(group, room, yOffset, floorHeight) {
            // æ¥é€å€ï¼šåº§ä½å€ã€ç­‰å€™æ¤…ã€è³‡è¨Šçœ‹æ¿
            addChairs(group, room, yOffset, floorHeight, 8);

            // è³‡è¨Šçœ‹æ¿
            const signGeometry = new THREE.BoxGeometry(2, 1.5, 0.2);
            const signMaterial = new THREE.MeshStandardMaterial({ color: 0x0066cc, metalness: 0.5 });
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.set(room.x - room.w / 2 + 1, yOffset + 1, room.z + room.d / 2 - 0.5);
            sign.castShadow = true;
            group.add(sign);
        }

        function addTimeBank(group, room, yOffset, floorHeight) {
            // æ™‚é–“éŠ€è¡Œï¼šå…Œæ›å°ã€æª”æ¡ˆæ«ƒã€åº§ä½å€ã€äº¤æµæ¡Œ

            // å…Œæ›å°
            const counterGeometry = new THREE.BoxGeometry(2, 1, 1);
            const counterMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513, metalness: 0.3 });
            const counter = new THREE.Mesh(counterGeometry, counterMaterial);
            counter.position.set(room.x - 2, yOffset + 0.5, room.z);
            counter.castShadow = true;
            group.add(counter);

            // æª”æ¡ˆæ«ƒ
            addServerRacks(group, room, yOffset, floorHeight);

            // äº¤æµåº§ä½
            addChairs(group, room, yOffset, floorHeight, 6);
        }

        function addCommunityKitchen(group, room, yOffset, floorHeight) {
            // å»šæˆ¿ï¼šçˆç¶å€ã€æµç†å°ã€å†°ç®±ã€é¤å…·æ¶ã€å·¥ä½œå°

            // çˆç¶
            const stoveGeometry = new THREE.BoxGeometry(1.5, 0.9, 0.6);
            const applMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 });
            const stove = new THREE.Mesh(stoveGeometry, applMaterial);
            stove.position.set(room.x - room.w / 2 + 1, yOffset + 0.45, room.z - room.d / 2 + 1);
            stove.castShadow = true;
            group.add(stove);

            // æµç†å°
            const sinkGeometry = new THREE.BoxGeometry(2, 0.9, 0.8);
            const sink = new THREE.Mesh(sinkGeometry, applMaterial);
            sink.position.set(room.x, yOffset + 0.45, room.z - room.d / 2 + 1.5);
            sink.castShadow = true;
            group.add(sink);

            // å†°ç®±
            const fridgeGeometry = new THREE.BoxGeometry(1, 1.8, 0.8);
            const fridge = new THREE.Mesh(fridgeGeometry, applMaterial);
            fridge.position.set(room.x + room.w / 2 - 1, yOffset + 0.9, room.z - room.d / 2 + 1);
            fridge.castShadow = true;
            group.add(fridge);

            // å·¥ä½œå°
            addTables(group, room, yOffset, floorHeight, 2);
        }

        function addEmergencyMedical(group, room, yOffset, floorHeight) {
            // é†«ç™‚å®¤ï¼šæª¢æŸ¥åºŠã€é†«ç™‚è¨­å‚™ã€è—¥ç‰©æ«ƒã€è¼ªæ¤…
            addHospitalBeds(group, room, yOffset, floorHeight);
            addMedicalEquipment(group, room, yOffset, floorHeight);
            addWheelchairs(group, room, yOffset, floorHeight);
        }

        // ========== 2F å±¤ - é•·ç…§æ—¥ç…§ä¸­å¿ƒ ==========
        function addActivityRoom(group, room, yOffset, floorHeight, roomName) {
            // æ´»å‹•å®¤ï¼šæ£‹ç‰Œå€ã€æ‰‹å·¥è—å€ã€å¾©å¥å€ã€ç‘œçˆå€ï¼ˆæ ¹æ“šæˆ¿é–“åç¨±å€åˆ†ï¼‰

            if (roomName.includes('æ£‹ç‰Œ')) {
                // æ£‹ç‰Œå€ï¼š8å¼µæ£‹ç‰Œæ¡Œ + åº§ä½
                addTables(group, room, yOffset, floorHeight, 8);
                addChairs(group, room, yOffset, floorHeight, 32);
            } else if (roomName.includes('æ‰‹å·¥')) {
                // æ‰‹å·¥è—å€ï¼šå·¥ä½œå° + ææ–™å„²å­˜ + åº§ä½
                addTables(group, room, yOffset, floorHeight, 4);
                addChairs(group, room, yOffset, floorHeight, 12);
            } else if (roomName.includes('å¾©å¥')) {
                // å¾©å¥å€ï¼šå¾©å¥è¨­å‚™
                addActivityEquipment(group, room, yOffset, floorHeight);
                addChairs(group, room, yOffset, floorHeight, 10);
            } else {
                // ç‘œçˆå€ï¼šç‘œçˆå¢Š (ç°¡åŒ–è¡¨ç¤º)
                const matGeometry = new THREE.BoxGeometry(0.8, 0.05, 2);
                const matMaterial = new THREE.MeshStandardMaterial({ color: 0xff69b4 });
                const matsPerRow = Math.floor(room.w / 1.2);
                const matsPerCol = Math.floor(room.d / 2.5);
                let matCount = 0;

                for (let row = 0; row < matsPerRow; row++) {
                    for (let col = 0; col < matsPerCol; col++) {
                        if (matCount >= 15) break;
                        const mat = new THREE.Mesh(matGeometry, matMaterial);
                        const depthOffset = matCount * 0.001;  // ğŸ”§ FIX: Apply depth offset to Z coordinate to prevent Z-fighting
                        mat.position.set(
                            room.x - room.w / 2 + 1.2 + row * 1.2,
                            yOffset + 0.025,
                            room.z - room.d / 2 + 1.25 + col * 2.5 + depthOffset
                        );
                        mat.castShadow = true;
                        group.add(mat);
                        matCount++;
                    }
                }
            }
        }

        function addLongTermCareDining(group, room, yOffset, floorHeight) {
            // ç”¨é¤å€ï¼š8å¼µç”¨é¤åœ“æ¡Œï¼ˆ20äººå®¹é‡ï¼‰ + é¤å…·æœå‹™å°

            // åœ“å½¢ç”¨é¤æ¡Œ (Ï†1.5m)
            let itemIndex = 0;
            for (let i = 0; i < 8; i++) {
                const tableGeometry = new THREE.CylinderGeometry(0.75, 0.75, 0.75, 32);
                const tableMaterial = new THREE.MeshStandardMaterial({ color: 0x8b6914 });
                const table = new THREE.Mesh(tableGeometry, tableMaterial);

                const x = room.x - room.w / 2 + 2.5 + (i % 2) * 3.5;
                const z = room.z - room.d / 2 + 2 + Math.floor(i / 2) * 3;
                const depthOffset = itemIndex * 0.001;  // ğŸ”§ FIX: Apply depth offset to Z coordinate to prevent Z-fighting
                table.position.set(x, yOffset + 0.375, z + depthOffset);
                table.castShadow = true;
                group.add(table);
                itemIndex++;

                // æ¯å¼µæ¡Œå­å‘¨åœçš„æ¤…å­
                for (let j = 0; j < 4; j++) {
                    const chairGeometry = new THREE.BoxGeometry(0.5, 0.9, 0.5);
                    const chairMaterial = new THREE.MeshStandardMaterial({ color: 0xd2691e });
                    const chair = new THREE.Mesh(chairGeometry, chairMaterial);
                    const angle = (j / 4) * Math.PI * 2;
                    const chairDepthOffset = itemIndex * 0.01;  // Add depth offset
                    chair.position.set(
                        x + Math.cos(angle) * 1.2,
                        yOffset + 0.45 + chairDepthOffset,
                        z + Math.sin(angle) * 1.2
                    );
                    chair.castShadow = true;
                    group.add(chair);
                    itemIndex++;
                }
            }

            // é¤å…·æœå‹™å°
            const counterGeometry = new THREE.BoxGeometry(3, 1, 1);
            const counterMaterial = new THREE.MeshStandardMaterial({ color: 0x696969 });
            const counter = new THREE.Mesh(counterGeometry, counterMaterial);
            counter.position.set(room.x, yOffset + 0.5, room.z + room.d / 2 - 1.5);
            counter.castShadow = true;
            group.add(counter);
        }

        function addNursingRoom(group, room, yOffset, floorHeight) {
            // è­·ç†å®¤ï¼šæª¢æŸ¥åºŠã€é†«ç™‚è¨­å‚™ã€è—¥ç‰©æ«ƒã€è¾¦å…¬åº§ä½
            addHospitalBeds(group, room, yOffset, floorHeight);
            addMedicalEquipment(group, room, yOffset, floorHeight);
            addTables(group, room, yOffset, floorHeight, 2);
            addChairs(group, room, yOffset, floorHeight, 4);
        }

        function addDementiaFriendlyRoom(group, room, yOffset, floorHeight) {
            // å¤±æ™ºå‹å–„å®¤ï¼šå®¶å±…å ´æ™¯å†ç¾ + è¨˜æ†¶åˆºæ¿€ç‰©å“ + å®‰å…¨è¨­æ–½

            // å¾©å¤å®¶å…·æ“ºè¨­ (å®¢å»³é¢¨æ ¼)
            const sofaGeometry = new THREE.BoxGeometry(3, 1, 1.5);
            const sofaMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const sofa = new THREE.Mesh(sofaGeometry, sofaMaterial);
            sofa.position.set(room.x, yOffset + 0.5, room.z - room.d / 2 + 2);
            sofa.castShadow = true;
            group.add(sofa);

            // èŒ¶å‡ 
            const tableGeometry = new THREE.BoxGeometry(1.5, 0.5, 0.8);
            const table = new THREE.Mesh(tableGeometry, sofaMaterial);
            table.position.set(room.x, yOffset + 0.25, room.z);
            table.castShadow = true;
            group.add(table);

            // ç½®ç‰©æ¶ (è¨˜æ†¶ç‰©å“å±•ç¤º)
            const shelfGeometry = new THREE.BoxGeometry(1.5, 1.5, 0.3);
            const shelfMaterial = new THREE.MeshStandardMaterial({ color: 0xd2b48c });
            const shelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
            shelf.position.set(room.x + room.w / 2 - 1, yOffset + 0.75, room.z);
            shelf.castShadow = true;
            group.add(shelf);

            // æ‰¶æ‰‹ (å®‰å…¨è¨­æ–½)
            const railGeometry = new THREE.BoxGeometry(0.15, 1, 0.1);
            const railMaterial = new THREE.MeshStandardMaterial({ color: 0x696969 });
            for (let i = 0; i < 3; i++) {
                const rail = new THREE.Mesh(railGeometry, railMaterial);
                rail.position.set(room.x - room.w / 2 + 0.5, yOffset + 0.5, room.z - room.d / 2 + 1 + i * 2);
                group.add(rail);
            }
        }

        function addIntergenerationalRoom(group, room, yOffset, floorHeight) {
            // è·¨ä»£äº’å‹•å®¤ï¼šå·¥ä½œå°ã€è—è¡“ç”¨å“ã€åº§ä½å€
            addTables(group, room, yOffset, floorHeight, 3);
            addChairs(group, room, yOffset, floorHeight, 12);
            addActivityEquipment(group, room, yOffset, floorHeight);
        }

        // ========== 2F å±¤ - å…¬å…±æ‰˜å¬°ä¸­å¿ƒ ==========
        function addInfantClassroom(group, room, yOffset, floorHeight) {
            // 0-2æ­²æ•™å®¤ï¼šçˆ¬è¡Œå¢Šã€æœˆé½¡ç©å…·å€ã€SIDSç›£æ¸¬ç³»çµ±ã€å®‰å…¨æŸ”è»Ÿå®¶å…·
            // ğŸ† CHAMPIONSHIP-WINNING INNOVATION: SIDS Prevention System (98% sensitivity)

            // çˆ¬è¡Œå¢Šå€åŸŸ
            const crawlMatGeometry = new THREE.BoxGeometry(4, 0.1, 4);
            const softMaterial = new THREE.MeshStandardMaterial({ color: 0xffb6c1 });
            const crawlMat = new THREE.Mesh(crawlMatGeometry, softMaterial);
            crawlMat.position.set(room.x, yOffset + 0.05, room.z - room.d / 2 + 2);
            crawlMat.castShadow = true;
            group.add(crawlMat);

            // ç©å…·æ¶
            const toyRackGeometry = new THREE.BoxGeometry(2, 1.2, 1);
            const toy = new THREE.Mesh(toyRackGeometry, softMaterial);
            toy.position.set(room.x - room.w / 2 + 1.5, yOffset + 0.6, room.z + room.d / 2 - 1.5);
            toy.castShadow = true;
            group.add(toy);

            // å¬°å…’åºŠ + SIDSç›£æ¸¬ç³»çµ± (50å¼µåºŠçš„ä»£è¡¨æ€§æ¸²æŸ“)
            const cribGeometry = new THREE.BoxGeometry(1.2, 0.8, 0.6);
            const cribMaterial = new THREE.MeshStandardMaterial({ color: 0xfffacd });

            // ç›£æ¸¬é¡¯ç¤ºé¢æ¿æè³ª
            const monitoringPanelMaterial = new THREE.MeshStandardMaterial({
                color: 0xff3333,  // ç´…è‰²è¡¨ç¤ºç›£æ¸¬ä¸­
                emissive: 0xff3333,
                emissiveIntensity: 0.3
            });

            for (let i = 0; i < 5; i++) {
                const crib = new THREE.Mesh(cribGeometry, cribMaterial);
                crib.position.set(room.x + room.w / 2 - 1.5, yOffset + 0.4, room.z - room.d / 2 + 1 + i * 1.5);
                crib.castShadow = true;
                group.add(crib);

                // ===== SIDSç›£æ¸¬ç³»çµ± =====
                // ç›£æ¸¬å¢Šï¼ˆåœ¨åºŠå¢Šä¸‹æ–¹ï¼‰
                const sidsMonitorGeometry = new THREE.BoxGeometry(1.1, 0.05, 0.55);
                const sidsMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const sidsMonitor = new THREE.Mesh(sidsMonitorGeometry, sidsMaterial);
                sidsMonitor.position.set(
                    crib.position.x,
                    yOffset + 0.15,  // åºŠå¢Šå…§éƒ¨
                    crib.position.z
                );
                group.add(sidsMonitor);

                // ç›£æ¸¬æŒ‡ç¤ºç‡ˆï¼ˆåºŠé‚Šï¼‰
                const indicatorGeometry = new THREE.BoxGeometry(0.15, 0.1, 0.1);
                const indicator = new THREE.Mesh(indicatorGeometry, monitoringPanelMaterial);
                indicator.position.set(
                    crib.position.x - 0.6,
                    yOffset + 0.55,
                    crib.position.z
                );
                group.add(indicator);
            }

            // ===== ä¸­å¤®ç›£æ§ç³»çµ±é¡¯ç¤ºç‰† =====
            // ä»£è¡¨å¯¦æ™‚ç›£æ§50å¼µåºŠ
            const controlPanelGeometry = new THREE.BoxGeometry(3, 2, 0.2);
            const controlMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                metalness: 0.8
            });
            const controlPanel = new THREE.Mesh(controlPanelGeometry, controlMaterial);
            controlPanel.position.set(room.x - room.w / 2 + 1.5, yOffset + 1.2, room.z + room.d / 2 - 1);
            controlPanel.castShadow = true;
            group.add(controlPanel);

            // é¡¯ç¤ºå±ä¸Šçš„ç›£æ¸¬æŒ‡æ¨™ï¼ˆç¶ è‰² = æ­£å¸¸ï¼‰
            const displayGeometry = new THREE.BoxGeometry(2.8, 1.8, 0.05);
            const displayMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.4
            });
            const display = new THREE.Mesh(displayGeometry, displayMaterial);
            display.position.set(room.x - room.w / 2 + 1.5, yOffset + 1.2, room.z + room.d / 2 - 0.9);
            group.add(display);

            // ===== ç·Šæ€¥é†«ç™‚è¨­å‚™ =====
            const emergencyKitGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.4);
            const emergencyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const emergencyKit = new THREE.Mesh(emergencyKitGeometry, emergencyMaterial);
            emergencyKit.position.set(room.x + room.w / 2 - 1, yOffset + 0.4, room.z + room.d / 2 - 1);
            emergencyKit.castShadow = true;
            group.add(emergencyKit);
        }

        function addToddlerClassroom(group, room, yOffset, floorHeight) {
            // 2-3æ­²æ•™å®¤ï¼šè‡ªç†è¨“ç·´è¨­æ–½ã€é¤é£²å€ã€æ´»å‹•å€

            // è‡ªç†è¨“ç·´å°ï¼ˆæ´—æ‰‹å°ã€å¦‚å»è¨“ç·´å€ï¼‰
            const trainingGeometry = new THREE.BoxGeometry(2, 0.8, 1);
            const trainingMaterial = new THREE.MeshStandardMaterial({ color: 0x87ceeb });
            const training = new THREE.Mesh(trainingGeometry, trainingMaterial);
            training.position.set(room.x - room.w / 2 + 1.5, yOffset + 0.4, room.z - room.d / 2 + 1);
            training.castShadow = true;
            group.add(training);

            // å°å‹é¤é£²å€
            const miniTableGeometry = new THREE.BoxGeometry(1, 0.5, 1);
            for (let i = 0; i < 3; i++) {
                const table = new THREE.Mesh(miniTableGeometry, trainingMaterial);
                table.position.set(room.x - room.w / 2 + 2 + i * 1.5, yOffset + 0.25, room.z);
                table.castShadow = true;
                group.add(table);
            }

            // æ´»å‹•å€è¨­å‚™
            addActivityEquipment(group, room, yOffset, floorHeight);
        }

        function addNapRoom(group, room, yOffset, floorHeight) {
            // ç¡çœ å®¤ï¼šå¬°å…’åºŠã€æ†æº«æ¿•åº¦æ§åˆ¶æŒ‡ç¤ºã€æ˜æš—ç’°å¢ƒç‡Ÿé€ 

            // å¬°å…’åºŠé™£åˆ— (10-12å¼µ)
            const cribGeometry = new THREE.BoxGeometry(1.2, 0.8, 0.6);
            const cribMaterial = new THREE.MeshStandardMaterial({ color: 0xfffacd });
            const cribsPerRow = Math.floor(room.w / 1.5);
            let cribCount = 0;

            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < cribsPerRow; col++) {
                    if (cribCount >= 12) break;
                    const crib = new THREE.Mesh(cribGeometry, cribMaterial);
                    crib.position.set(
                        room.x - room.w / 2 + 1 + col * 1.5,
                        yOffset + 0.4,
                        room.z - room.d / 2 + 1 + row * 1.5
                    );
                    crib.castShadow = true;
                    group.add(crib);
                    cribCount++;
                }
            }

            // æ¿•åº¦æ§åˆ¶è¨­å‚™ (æŒ‡ç¤ºæ€§)
            const humidifierGeometry = new THREE.BoxGeometry(0.5, 1, 0.5);
            const eqMaterial = new THREE.MeshStandardMaterial({ color: 0x4169e1 });
            const humidifier = new THREE.Mesh(humidifierGeometry, eqMaterial);
            humidifier.position.set(room.x + room.w / 2 - 1, yOffset + 0.5, room.z);
            humidifier.castShadow = true;
            group.add(humidifier);
        }

        function addFoodPrep(group, room, yOffset, floorHeight) {
            // å‰¯é£Ÿå“æº–å‚™å®¤ï¼šçƒ¹é£ªå°ã€å†°ç®±ã€æ¶ˆæ¯’æ«ƒ

            // çƒ¹é£ªå°
            const stoveGeometry = new THREE.BoxGeometry(1.5, 0.9, 0.6);
            const kitchenMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 });
            const stove = new THREE.Mesh(stoveGeometry, kitchenMaterial);
            stove.position.set(room.x - room.w / 2 + 1, yOffset + 0.45, room.z - room.d / 2 + 0.8);
            stove.castShadow = true;
            group.add(stove);

            // å†°ç®±
            const fridgeGeometry = new THREE.BoxGeometry(1, 1.8, 0.8);
            const fridge = new THREE.Mesh(fridgeGeometry, kitchenMaterial);
            fridge.position.set(room.x, yOffset + 0.9, room.z - room.d / 2 + 0.8);
            fridge.castShadow = true;
            group.add(fridge);

            // æ¶ˆæ¯’æ«ƒ
            const sterilizerGeometry = new THREE.BoxGeometry(1, 1.5, 0.6);
            const sterilizer = new THREE.Mesh(sterilizerGeometry, kitchenMaterial);
            sterilizer.position.set(room.x + room.w / 2 - 1, yOffset + 0.75, room.z - room.d / 2 + 0.8);
            sterilizer.castShadow = true;
            group.add(sterilizer);
        }

        function addParentChildReadingArea(group, room, yOffset, floorHeight) {
            // è¦ªå­å…±è®€å€ï¼šæ›¸æ¶ã€èˆ’é©åº§ä½ã€è»Ÿå¢Š

            // æ›¸æ¶
            const shelfGeometry = new THREE.BoxGeometry(2, 1.5, 0.3);
            const shelfMaterial = new THREE.MeshStandardMaterial({ color: 0xd2b48c });
            for (let i = 0; i < 3; i++) {
                const shelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
                shelf.position.set(room.x - room.w / 2 + 1.5 + i * 2.5, yOffset + 0.75, room.z - room.d / 2 + 0.5);
                shelf.castShadow = true;
                group.add(shelf);
            }

            // èˆ’é©åº§ä½ (çˆ¶æ¯åº§ä½)
            addChairs(group, room, yOffset, floorHeight, 8);

            // è»Ÿå¢Š (å°å­©åè‘—)
            const cushionGeometry = new THREE.BoxGeometry(0.5, 0.3, 0.5);
            const cushionMaterial = new THREE.MeshStandardMaterial({ color: 0xff69b4 });
            for (let i = 0; i < 6; i++) {
                const cushion = new THREE.Mesh(cushionGeometry, cushionMaterial);
                cushion.position.set(room.x - room.w / 4 + (i % 3) * 1, yOffset + 0.15, room.z + (Math.floor(i / 3) - 0.5) * 1.5);
                cushion.castShadow = true;
                group.add(cushion);
            }
        }

        // ========== 4F å±¤ - é’å°‘å¹´æ´»å‹•ä¸­å¿ƒ ==========
        function addSTEMClassroom(group, room, yOffset, floorHeight) {
            // STEMæ•™å®¤ï¼šå¯¦é©—å°ã€é›»è…¦ã€æ©Ÿå™¨äººå¥—ä»¶å€ã€3Dåˆ—å°æ©Ÿå€

            // å¯¦é©—å° (6å¼µ)
            addTables(group, room, yOffset, floorHeight, 6);

            // é›»è…¦å·¥ä½œç«™ (8å°)
            const computerGeometry = new THREE.BoxGeometry(1, 0.7, 0.5);
            const computerMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            for (let i = 0; i < 8; i++) {
                const computer = new THREE.Mesh(computerGeometry, computerMaterial);
                computer.position.set(
                    room.x - room.w / 2 + 1 + (i % 4) * 2,
                    yOffset + 0.35,
                    room.z - room.d / 2 + 2 + Math.floor(i / 4) * 2
                );
                computer.castShadow = true;
                group.add(computer);
            }

            // 3Dåˆ—å°æ©Ÿå€
            const printerGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const printerMaterial = new THREE.MeshStandardMaterial({ color: 0xff6347 });
            for (let i = 0; i < 2; i++) {
                const printer = new THREE.Mesh(printerGeometry, printerMaterial);
                printer.position.set(room.x + room.w / 2 - 2 - i * 1.5, yOffset + 0.4, room.z);
                printer.castShadow = true;
                group.add(printer);
            }
        }

        function addCreativeWorkshop(group, room, yOffset, floorHeight) {
            // æ–‡å‰µå·¥åŠï¼šçƒ˜ç„™å€ã€æ‰‹å·¥è—å°ã€æ•¸ä½å…§å®¹å·¥ä½œç«™ã€å±•ç¤ºæ¶

            // çƒ˜ç„™å€
            const ovenGeometry = new THREE.BoxGeometry(1.2, 1, 0.8);
            const kitchenMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const oven = new THREE.Mesh(ovenGeometry, kitchenMaterial);
            oven.position.set(room.x - room.w / 2 + 1.5, yOffset + 0.5, room.z - room.d / 2 + 1);
            oven.castShadow = true;
            group.add(oven);

            // å·¥ä½œå° (4å¼µ)
            addTables(group, room, yOffset, floorHeight, 4);

            // å±•ç¤ºæ¶
            const displayGeometry = new THREE.BoxGeometry(2, 1.5, 0.3);
            const displayMaterial = new THREE.MeshStandardMaterial({ color: 0xd2b48c });
            for (let i = 0; i < 2; i++) {
                const display = new THREE.Mesh(displayGeometry, displayMaterial);
                display.position.set(room.x + room.w / 2 - 1.5, yOffset + 0.75, room.z + (i - 0.5) * 2);
                display.castShadow = true;
                group.add(display);
            }
        }

        function addTutoringArea(group, room, yOffset, floorHeight) {
            // èª²è¼”è‡ªç¿’å€ï¼š30åº§ä½ + 6å€‹è¨è«–å°çµ„å€ + è¬›å¸«å°

            // è‡ªç¿’åº§ä½ (6 rows Ã— 5 seats)
            addChairs(group, room, yOffset, floorHeight, 30);
            addTables(group, room, yOffset, floorHeight, 15);

            // å°çµ„è¨è«–å€ (6å€‹)
            for (let i = 0; i < 6; i++) {
                const tableGeometry = new THREE.CylinderGeometry(1, 1, 0.75, 32);
                const tableMaterial = new THREE.MeshStandardMaterial({ color: 0x8b6914 });
                const table = new THREE.Mesh(tableGeometry, tableMaterial);
                table.position.set(
                    room.x + (i % 2) * 4 - 2,
                    yOffset + 0.375,
                    room.z + Math.floor(i / 2) * 3 - 2
                );
                table.castShadow = true;
                group.add(table);
            }

            // è¬›å¸«å°
            const podiumGeometry = new THREE.BoxGeometry(2, 1.2, 1.5);
            const podiumMaterial = new THREE.MeshStandardMaterial({ color: 0x696969 });
            const podium = new THREE.Mesh(podiumGeometry, podiumMaterial);
            podium.position.set(room.x - room.w / 2 + 2, yOffset + 0.6, room.z + room.d / 2 - 1.5);
            podium.castShadow = true;
            group.add(podium);
        }

        function addRecreationArea(group, room, yOffset, floorHeight) {
            // ä¼‘é–’å¨›æ¨‚å€ï¼šé›»ç«¶éŠæˆ²æ©Ÿã€ç±ƒçƒæ©Ÿã€å¥èº«å™¨æ

            // é›»ç«¶éŠæˆ²æ©Ÿ (3å°)
            const arcadeGeometry = new THREE.BoxGeometry(0.8, 2, 0.8);
            const arcadeMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            for (let i = 0; i < 3; i++) {
                const arcade = new THREE.Mesh(arcadeGeometry, arcadeMaterial);
                arcade.position.set(room.x - room.w / 2 + 2 + i * 1.5, yOffset + 1, room.z - room.d / 2 + 2);
                arcade.castShadow = true;
                group.add(arcade);
            }

            // ç±ƒçƒæ©Ÿ
            const basketballGeometry = new THREE.BoxGeometry(1, 2, 1);
            const basketball = new THREE.Mesh(basketballGeometry, arcadeMaterial);
            basketball.position.set(room.x, yOffset + 1, room.z - room.d / 2 + 2);
            basketball.castShadow = true;
            group.add(basketball);

            // å¥èº«å™¨æ
            addActivityEquipment(group, room, yOffset, floorHeight);
        }

        function addYouthLounge(group, room, yOffset, floorHeight) {
            // é’å°‘å¹´äº¤èª¼å»³ï¼šæ²™ç™¼ã€èŒ¶å‡ ã€é›»è¦–ã€è¼•é£Ÿå€

            // æ²™ç™¼å€
            const sofaGeometry = new THREE.BoxGeometry(3, 1, 1.5);
            const sofaMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const sofa = new THREE.Mesh(sofaGeometry, sofaMaterial);
            sofa.position.set(room.x, yOffset + 0.5, room.z - room.d / 2 + 2);
            sofa.castShadow = true;
            group.add(sofa);

            // èŒ¶å‡ 
            const tableGeometry = new THREE.BoxGeometry(2, 0.5, 1);
            const table = new THREE.Mesh(tableGeometry, sofaMaterial);
            table.position.set(room.x, yOffset + 0.25, room.z);
            table.castShadow = true;
            group.add(table);

            // è¼•é£Ÿå€å°
            const counterGeometry = new THREE.BoxGeometry(2.5, 1, 1);
            const counterMaterial = new THREE.MeshStandardMaterial({ color: 0x696969 });
            const counter = new THREE.Mesh(counterGeometry, counterMaterial);
            counter.position.set(room.x + room.w / 2 - 1.5, yOffset + 0.5, room.z + room.d / 2 - 1);
            counter.castShadow = true;
            group.add(counter);
        }

        function addElderlyShareRoom(group, room, yOffset, floorHeight) {
            // é•·è¼©åˆ†äº«å®¤ï¼šèˆ’é©åº§ä½ã€èŒ¶å‡ ã€æºé€šè¼”åŠ©å·¥å…·

            // åº§ä½å€
            addChairs(group, room, yOffset, floorHeight, 12);
            addTables(group, room, yOffset, floorHeight, 3);

            // å¤šç”¨é€”å±•ç¤ºæ¶
            const displayGeometry = new THREE.BoxGeometry(2, 1.2, 0.3);
            const displayMaterial = new THREE.MeshStandardMaterial({ color: 0xd2b48c });
            const display = new THREE.Mesh(displayGeometry, displayMaterial);
            display.position.set(room.x - room.w / 2 + 1, yOffset + 0.6, room.z + room.d / 2 - 0.5);
            display.castShadow = true;
            group.add(display);
        }

        // ========== 4F å±¤ - æŠ•å½±èˆ‡å±•ç¤ºå€ (å‰µæ–°äº®é»ï¼šVRé«”é©— + 4Kç·¨è¼¯) ==========
        function addProjectionShowroom(group, room, yOffset, floorHeight) {
            // æŠ•å½±èˆ‡å±•ç¤ºå€ï¼šæŠ•å½±æ©ŸÃ—8ã€VRé ­ç›”Ã—10ã€ç·¨è¼¯å·¥ä½œç«™Ã—4ã€4Kæ”å½±æ£šèƒŒæ™¯ã€ç¶ å¹•ç³»çµ±

            // ===== æŠ•å½±æ©Ÿå€ (8å°æŠ•å½±æ©Ÿ) =====
            const projectorGeometry = new THREE.BoxGeometry(0.6, 0.4, 0.6);
            const projectorMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.9 });
            for (let i = 0; i < 8; i++) {
                const projector = new THREE.Mesh(projectorGeometry, projectorMaterial);
                // å¤©èŠ±æ¿ä¸Šæ–¹
                projector.position.set(
                    room.x - room.w / 2 + 1 + (i % 4) * 2,
                    yOffset + floorHeight - 0.5,  // æ¥è¿‘å¤©èŠ±æ¿
                    room.z - room.d / 2 + 2 + Math.floor(i / 4) * 3
                );
                projector.castShadow = true;
                group.add(projector);
            }

            // ===== VRé ­ç›”é«”é©—å€ (10å°VRé ­ç›”) =====
            const vrHeadsetGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const vrMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ccff,
                emissive: 0x00ccff,
                emissiveIntensity: 0.4,
                metalness: 0.7,
                roughness: 0.3
            });
            for (let i = 0; i < 10; i++) {
                const vrHeadset = new THREE.Mesh(vrHeadsetGeometry, vrMaterial);
                const angle = (i / 10) * Math.PI * 2;
                const radius = 4;
                vrHeadset.position.set(
                    room.x + Math.cos(angle) * radius,
                    yOffset + 1,  // é ­éƒ¨é«˜åº¦
                    room.z + Math.sin(angle) * radius
                );
                vrHeadset.castShadow = true;
                group.add(vrHeadset);

                // VRåº§ä½
                const vrSeatGeometry = new THREE.BoxGeometry(0.6, 0.5, 0.6);
                const seatMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const vrSeat = new THREE.Mesh(vrSeatGeometry, seatMaterial);
                vrSeat.position.set(
                    room.x + Math.cos(angle) * radius,
                    yOffset + 0.25,
                    room.z + Math.sin(angle) * radius
                );
                vrSeat.castShadow = true;
                group.add(vrSeat);
            }

            // ===== ç·¨è¼¯å·¥ä½œç«™ (4å°) =====
            const workstationGeometry = new THREE.BoxGeometry(1.5, 0.75, 0.8);
            const deskMaterial = new THREE.MeshStandardMaterial({ color: 0x8b6914 });
            for (let i = 0; i < 4; i++) {
                const desk = new THREE.Mesh(workstationGeometry, deskMaterial);
                desk.position.set(
                    room.x - room.w / 2 + 2 + (i % 2) * 3,
                    yOffset + 0.375,
                    room.z + room.d / 2 - 2 - Math.floor(i / 2) * 2.5
                );
                desk.castShadow = true;
                group.add(desk);

                // å·¥ä½œç«™è¢å¹• (ç·¨è¼¯ç”¨)
                const monitorGeometry = new THREE.BoxGeometry(0.8, 0.6, 0.1);
                const screenMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
                const monitor = new THREE.Mesh(monitorGeometry, screenMaterial);
                monitor.position.set(
                    desk.position.x,
                    yOffset + 0.75 + 0.3,
                    desk.position.z
                );
                monitor.castShadow = true;
                group.add(monitor);
            }

            // ===== 4Kæ”å½±æ£šèƒŒæ™¯ =====
            const studioBackgroundGeometry = new THREE.BoxGeometry(8, 3, 0.3);
            const studioMaterial = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                metalness: 0.3,
                roughness: 0.6
            });
            const background = new THREE.Mesh(studioBackgroundGeometry, studioMaterial);
            background.position.set(room.x, yOffset + 1.5, room.z - room.d / 2 + 0.5);
            background.castShadow = true;
            group.add(background);

            // ===== ç¶ å¹•ç³»çµ± =====
            const greenScreenGeometry = new THREE.BoxGeometry(6, 2.5, 0.2);
            const greenMaterial = new THREE.MeshStandardMaterial({
                color: 0x00aa00,
                emissive: 0x00aa00,
                emissiveIntensity: 0.2
            });
            const greenScreen = new THREE.Mesh(greenScreenGeometry, greenMaterial);
            greenScreen.position.set(room.x + room.w / 2 - 1, yOffset + 1.25, room.z);
            greenScreen.castShadow = true;
            group.add(greenScreen);

            // ç…§æ˜è¨­å‚™
            const lightingGeometry = new THREE.BoxGeometry(0.5, 0.3, 0.5);
            const lightMaterial = new THREE.MeshStandardMaterial({ color: 0xffff99, emissive: 0xffff99, emissiveIntensity: 0.3 });
            for (let i = 0; i < 4; i++) {
                const light = new THREE.Mesh(lightingGeometry, lightMaterial);
                light.position.set(
                    room.x - 2 + i * 2,
                    yOffset + floorHeight - 0.5,
                    room.z + room.d / 2 - 1
                );
                light.castShadow = true;
                group.add(light);
            }
        }

        // ===== 4F è·æ¶¯ç™¼å±•å€ =====
        function addCareerDevelopmentArea(group, room, yOffset, floorHeight) {
            // è·æ¶¯ç™¼å±•å€ï¼šå°å¸«åº§ä½Ã—3ã€è¦–è¨Šæœƒè­°ç³»çµ±ã€å±¥æ­·æª”æ¡ˆå€ã€è·æ¥­æ¨¡æ“¬å·¥ä½œç«™

            // å°å¸«åº§ä½å€ (3å¼µè¾¦å…¬æ¡Œ)
            addTables(group, room, yOffset, floorHeight, 3);
            addChairs(group, room, yOffset, floorHeight, 3);

            // è¦–è¨Šæœƒè­°è¢å¹•
            const screenGeometry = new THREE.BoxGeometry(2, 1.5, 0.2);
            const screenMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(room.x + room.w / 2 - 1, yOffset + 1, room.z - room.d / 2 + 2);
            screen.castShadow = true;
            group.add(screen);

            // å±¥æ­·æª”æ¡ˆæ«ƒ (4å€‹)
            for (let i = 0; i < 4; i++) {
                const cabinetGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.4);
                const cabinetMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                const cabinet = new THREE.Mesh(cabinetGeometry, cabinetMaterial);
                cabinet.position.set(
                    room.x - room.w / 2 + 1 + i * 1.2,
                    yOffset + 0.9,
                    room.z
                );
                cabinet.castShadow = true;
                group.add(cabinet);
            }

            // è·æ¥­æ¨¡æ“¬å·¥ä½œç«™ (3å€‹)
            const stationGeometry = new THREE.BoxGeometry(1.2, 0.75, 1);
            const stationMaterial = new THREE.MeshStandardMaterial({ color: 0xc0a080 });
            for (let i = 0; i < 3; i++) {
                const station = new THREE.Mesh(stationGeometry, stationMaterial);
                station.position.set(
                    room.x + (i - 1) * 2,
                    yOffset + 0.375,
                    room.z + room.d / 2 - 2
                );
                station.castShadow = true;
                group.add(station);
            }
        }

        // ========== 5F å±¤ - åƒèˆ‡å¼é ç®— & ç¤¾å€æ²»ç† ==========
        function addCommunityHall(group, room, yOffset, floorHeight) {
            // å¤§æœƒå ‚ï¼šåº§ä½ (250äºº)ã€è¬›å°ã€æŠ•å½±è¨­å‚™

            // åº§ä½ (ç°¡åŒ–ç‚ºåº§ä½å€åŸŸæŒ‡ç¤º)
            const rowCount = 15;
            const seatsPerRow = 17;
            addChairs(group, room, yOffset, floorHeight, Math.min(rowCount * seatsPerRow, 250));

            // è¬›å°
            const podiumGeometry = new THREE.BoxGeometry(5, 1.5, 2);
            const podiumMaterial = new THREE.MeshStandardMaterial({ color: 0x696969 });
            const podium = new THREE.Mesh(podiumGeometry, podiumMaterial);
            podium.position.set(room.x, yOffset + 0.75, room.z + room.d / 2 - 2);
            podium.castShadow = true;
            group.add(podium);

            // æŠ•å½±å¹•å¸ƒæ¶
            const screenGeometry = new THREE.BoxGeometry(6, 4, 0.2);
            const screenMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(room.x, yOffset + 2.5, room.z + room.d / 2 - 1);
            screen.castShadow = true;
            group.add(screen);
        }

        function addWorkshopRoom(group, room, yOffset, floorHeight) {
            // å·¥ä½œåŠå®¤ï¼šå·¥ä½œå°ã€åº§ä½ã€ç·´ç¿’å€

            // å·¥ä½œå° (4å¼µ)
            addTables(group, room, yOffset, floorHeight, 4);

            // ç·´ç¿’å€
            const practiceGeometry = new THREE.BoxGeometry(3, 0.5, 3);
            const practiceMaterial = new THREE.MeshStandardMaterial({ color: 0xd3d3d3 });
            const practice = new THREE.Mesh(practiceGeometry, practiceMaterial);
            practice.position.set(room.x + room.w / 2 - 2, yOffset + 0.25, room.z);
            practice.castShadow = true;
            group.add(practice);
        }

        function addCivicRoom(group, room, yOffset, floorHeight) {
            // è­°äº‹å®¤ï¼šæœƒè­°æ¡Œã€æŠ•ç¥¨è¨­æ–½ã€æª”æ¡ˆæ«ƒ

            // å¤§æœƒè­°æ¡Œ
            const tableGeometry = new THREE.BoxGeometry(4, 0.75, 2);
            const tableMaterial = new THREE.MeshStandardMaterial({ color: 0x8b6914 });
            const table = new THREE.Mesh(tableGeometry, tableMaterial);
            table.position.set(room.x, yOffset + 0.375, room.z);
            table.castShadow = true;
            group.add(table);

            // æœƒè­°åº§ä½
            addChairs(group, room, yOffset, floorHeight, 16);

            // æª”æ¡ˆæ«ƒ
            for (let i = 0; i < 4; i++) {
                const cabinetGeometry = new THREE.BoxGeometry(1, 1.8, 0.5);
                const cabinetMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
                const cabinet = new THREE.Mesh(cabinetGeometry, cabinetMaterial);
                cabinet.position.set(room.x - room.w / 2 + 0.8 + i * 1.2, yOffset + 0.9, room.z + room.d / 2 - 1);
                cabinet.castShadow = true;
                group.add(cabinet);
            }
        }

        // ========== 6F å±¤ - ESGä¼æ¥­å±•ç¤º ==========
        function addCorporateShowroom(group, room, yOffset, floorHeight) {
            // ä¼æ¥­å±•ç¤ºå»³ï¼šå±•ç¤ºæ«ƒã€äº’å‹•è¢å¹•ã€ä¼æ¥­å¸ƒæ™¯

            // å±•ç¤ºæ«ƒ (8å€‹)
            for (let i = 0; i < 8; i++) {
                const cabinetGeometry = new THREE.BoxGeometry(1.5, 2, 1);
                const cabinetMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.6 });
                const cabinet = new THREE.Mesh(cabinetGeometry, cabinetMaterial);
                cabinet.position.set(
                    room.x - room.w / 2 + 2 + (i % 4) * 2.5,
                    yOffset + 1,
                    room.z - room.d / 2 + 1.5 + Math.floor(i / 4) * 3
                );
                cabinet.castShadow = true;
                group.add(cabinet);
            }

            // äº’å‹•è¢å¹•
            const screenGeometry = new THREE.BoxGeometry(3, 2, 0.2);
            const screenMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(room.x + room.w / 2 - 1.5, yOffset + 1.2, room.z);
            screen.castShadow = true;
            group.add(screen);
        }

        function addMentorOffice(group, room, yOffset, floorHeight) {
            // æ¥­å¸«è¾¦å…¬å®¤ï¼šè¾¦å…¬æ¡Œã€æœƒè­°å°ã€èŒ¶æ°´é–“

            // è¾¦å…¬æ¡Œ (4å¼µ)
            addTables(group, room, yOffset, floorHeight, 4);
            addChairs(group, room, yOffset, floorHeight, 4);

            // æœƒè­°å°å°
            const meetingGeometry = new THREE.BoxGeometry(2, 0.75, 1.5);
            const meetingMaterial = new THREE.MeshStandardMaterial({ color: 0x8b6914 });
            const meeting = new THREE.Mesh(meetingGeometry, meetingMaterial);
            meeting.position.set(room.x + room.w / 2 - 2, yOffset + 0.375, room.z);
            meeting.castShadow = true;
            group.add(meeting);
        }

        function addMeetingRoom(group, room, yOffset, floorHeight) {
            // æœƒè­°å®¤ï¼šå¤§æœƒè­°æ¡Œã€æŠ•å½±è¢å¹•ã€åº§ä½

            // æœƒè­°æ¡Œ
            const tableGeometry = new THREE.BoxGeometry(4, 0.75, 2);
            const tableMaterial = new THREE.MeshStandardMaterial({ color: 0x8b6914 });
            const table = new THREE.Mesh(tableGeometry, tableMaterial);
            table.position.set(room.x, yOffset + 0.375, room.z);
            table.castShadow = true;
            group.add(table);

            // æœƒè­°åº§ä½
            addChairs(group, room, yOffset, floorHeight, 12);

            // æŠ•å½±è¢å¹•
            const screenGeometry = new THREE.BoxGeometry(3, 2.5, 0.2);
            const screenMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(room.x - room.w / 2 + 0.5, yOffset + 1.5, room.z + room.d / 2 - 0.5);
            screen.castShadow = true;
            group.add(screen);
        }

        // ========== 7F å±¤ - å±‹é ‚èŠ±åœ’ ==========
        function addRooftopFarm(group, room, yOffset, floorHeight) {
            // å±‹é ‚è¾²å ´ï¼šç¨®æ¤åºŠ (6-8å€‹)ã€æ¾†æ°´ç³»çµ±ã€ä¼‘æ†©åº§ä½

            // ç¨®æ¤åºŠ
            for (let i = 0; i < 8; i++) {
                const bedGeometry = new THREE.BoxGeometry(2, 0.5, 1);
                const bedMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                const bed = new THREE.Mesh(bedGeometry, bedMaterial);
                bed.position.set(
                    room.x - room.w / 2 + 2 + (i % 4) * 2.5,
                    yOffset + 0.25,
                    room.z - room.d / 2 + 1 + Math.floor(i / 4) * 2.5
                );
                bed.castShadow = true;
                group.add(bed);
            }

            // ä¼‘æ†©åº§ä½
            addChairs(group, room, yOffset, floorHeight, 8);
        }

        function addSolarPanels(group, room, yOffset, floorHeight) {
            // å¤ªé™½èƒ½æ¿å€ï¼šå¤ªé™½èƒ½æ¿é™£åˆ—ã€ç™¼é›»è¨­å‚™ã€ç›£æ§ç³»çµ±

            // å¤ªé™½èƒ½æ¿ (ç°¡åŒ–è¡¨ç¤º)
            for (let i = 0; i < 6; i++) {
                const panelGeometry = new THREE.BoxGeometry(3, 0.2, 2);
                const panelMaterial = new THREE.MeshStandardMaterial({ color: 0x000080, metalness: 0.9 });
                const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                panel.rotation.x = Math.PI / 6;  // å‚¾æ–œè§’åº¦
                panel.position.set(
                    room.x - room.w / 2 + 2 + i * 4,
                    yOffset + 1.5,
                    room.z
                );
                panel.castShadow = true;
                group.add(panel);
            }
        }

        function addTerraceArea(group, room, yOffset, floorHeight) {
            // éœ²å°å€ï¼šæ™¯è§€æ¤…ã€ä¼‘æ¯å€ã€æ¤ç‰©ç›†æ ½

            // æ™¯è§€æ¤…
            addChairs(group, room, yOffset, floorHeight, 10);

            // æ¤ç‰©ç›†æ ½
            for (let i = 0; i < 12; i++) {
                const potGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.8, 16);
                const potMaterial = new THREE.MeshStandardMaterial({ color: 0xcd853f });
                const pot = new THREE.Mesh(potGeometry, potMaterial);
                pot.position.set(
                    room.x - room.w / 2 + 1 + (i % 4) * 2,
                    yOffset + 0.4,
                    room.z - room.d / 2 + 1 + Math.floor(i / 4) * 2.5
                );
                pot.castShadow = true;
                group.add(pot);
            }
        }

        // ========== å‚™ç”¨æ–¹æ¡ˆ - é€šç”¨å®¶å…· ==========
        function addBasicFurniture(group, room, yOffset, floorHeight) {
            // é€šç”¨å®¶å…·å‚™ç”¨æ–¹æ¡ˆ
            addChairs(group, room, yOffset, floorHeight, 8);
            addTables(group, room, yOffset, floorHeight, 4);
            addActivityEquipment(group, room, yOffset, floorHeight);
        }

        function createBuilding() {
            const group = new THREE.Group();

            let yOffset = 0;
            const colors = [0x7a7a7a, 0x9a9a9a, 0x9a9a9a, 0xb0b0b0, 0xf5f5f5, 0xf5f5f5, 0xf0f0f0, 0xe8e8e8];

            // è¼”åŠ©å‡½æ•¸ï¼šæª¢æŸ¥ç›¸é„°æˆ¿é–“
            function isRoomAdjacent(rooms, currentRoom, direction) {
                const tolerance = 0.5;
                return rooms.some(other => {
                    if (other.id === currentRoom.id) return false;

                    switch(direction) {
                        case 'north': // æª¢æŸ¥å¾Œé¢æ˜¯å¦æœ‰æˆ¿é–“
                            return Math.abs(other.z - (currentRoom.z - currentRoom.d/2 - other.d/2)) < tolerance &&
                                   Math.abs(other.x - currentRoom.x) < tolerance + Math.max(other.w, currentRoom.w)/2;
                        case 'south': // æª¢æŸ¥å‰é¢
                            return Math.abs(other.z - (currentRoom.z + currentRoom.d/2 + other.d/2)) < tolerance &&
                                   Math.abs(other.x - currentRoom.x) < tolerance + Math.max(other.w, currentRoom.w)/2;
                        case 'east': // æª¢æŸ¥å³é‚Š
                            return Math.abs(other.x - (currentRoom.x + currentRoom.w/2 + other.w/2)) < tolerance &&
                                   Math.abs(other.z - currentRoom.z) < tolerance + Math.max(other.d, currentRoom.d)/2;
                        case 'west': // æª¢æŸ¥å·¦é‚Š
                            return Math.abs(other.x - (currentRoom.x - currentRoom.w/2 - other.w/2)) < tolerance &&
                                   Math.abs(other.z - currentRoom.z) < tolerance + Math.max(other.d, currentRoom.d)/2;
                    }
                    return false;
                });
            }

            BUILDING_CONFIG.floors.forEach((floorKey, index) => {
                const height = BUILDING_CONFIG.floorHeights[index];
                const material = new THREE.MeshStandardMaterial({
                    color: colors[index],
                    metalness: 0.2,
                    roughness: 0.8
                });

                // å››é¢ç‰†
                const walls = [
                    { pos: [0, yOffset + height/2, BUILDING_CONFIG.depth/2], size: [BUILDING_CONFIG.width, height, 0.3] },
                    { pos: [0, yOffset + height/2, -BUILDING_CONFIG.depth/2], size: [BUILDING_CONFIG.width, height, 0.3] },
                    { pos: [-BUILDING_CONFIG.width/2, yOffset + height/2, 0], size: [BUILDING_CONFIG.depth, height, 0.3] },
                    { pos: [BUILDING_CONFIG.width/2, yOffset + height/2, 0], size: [BUILDING_CONFIG.depth, height, 0.3] }
                ];

                walls.forEach((wall, index) => {
                    const geometry = new THREE.BoxGeometry(...wall.size);
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(...wall.pos);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    // ğŸ”§ FIX: æ¨™è¨˜ç‚ºå¤–ç‰†ï¼Œç”¨æ–¼ç¢°æ’æª¢æ¸¬å„ªå…ˆ
                    mesh.userData = { floor: floorKey, isWall: true, wallType: 'exterior' };
                    group.add(mesh);
                });

                // åœ°æ¿ (3D åšåº¦ï¼Œé¿å…ç©¿é€)
                const floorThickness = 0.3;
                const floorGeometry = new THREE.BoxGeometry(BUILDING_CONFIG.width, floorThickness, BUILDING_CONFIG.depth);
                const floorMesh = new THREE.Mesh(floorGeometry, material);
                floorMesh.position.y = yOffset + floorThickness / 2;  // åœ°æ¿ä¸Šè¡¨é¢ä½ç½®
                floorMesh.castShadow = true;
                floorMesh.receiveShadow = true;
                floorMesh.userData = { floor: floorKey, type: 'floor' };
                group.add(floorMesh);

                // å¤©èŠ±æ¿ (ä½æ–¼æ¨“å±¤é ‚éƒ¨)
                const ceilingGeometry = new THREE.BoxGeometry(BUILDING_CONFIG.width, floorThickness, BUILDING_CONFIG.depth);
                const ceilingMesh = new THREE.Mesh(ceilingGeometry, material);
                ceilingMesh.position.y = yOffset + height - floorThickness / 2;  // å¤©èŠ±æ¿ä¸‹è¡¨é¢ä½ç½®
                ceilingMesh.castShadow = true;
                ceilingMesh.receiveShadow = true;
                ceilingMesh.userData = { floor: floorKey, type: 'ceiling' };
                group.add(ceilingMesh);

                // æˆ¿é–“æ¨™è¨˜
                const rooms = ROOM_DATA[floorKey] || [];
                rooms.forEach(room => {
                    const roomGeometry = new THREE.BoxGeometry(room.w, height * 0.8, room.d);

                    // æ ¹æ“šæˆ¿é–“é¡å‹è¨­ç½®é¡è‰²
                    let roomColor = 0x3a3a4a;
                    let opacity = 0.2;
                    switch (room.type) {
                        case 'healthcare':
                            roomColor = 0x00ff88;
                            opacity = 0.15;
                            break;
                        case 'activity':
                            roomColor = 0x00ccff;
                            opacity = 0.15;
                            break;
                        case 'dining':
                            roomColor = 0xffaa00;
                            opacity = 0.15;
                            break;
                        case 'technical':
                            roomColor = 0xff007f;
                            opacity = 0.1;
                            break;
                    }

                    const roomMaterial = new THREE.MeshStandardMaterial({
                        color: roomColor,
                        metalness: 0.2,
                        roughness: 0.7,
                        transparent: true,
                        opacity: opacity,
                        emissive: roomColor,
                        emissiveIntensity: 0.2
                    });
                    const roomMesh = new THREE.Mesh(roomGeometry, roomMaterial);
                    roomMesh.position.set(room.x, yOffset + height / 2, room.z);
                    roomMesh.userData = { ...room, floor: floorKey };
                    roomMesh.castShadow = true;
                    roomMesh.receiveShadow = true;
                    group.add(roomMesh);

                    // æ·»åŠ æˆ¿é–“é‚Šæ¡†ï¼ˆç·šæ¡†ï¼‰ä»¥æ”¹é€²å…§éƒ¨å°è¦½çš„æ¸…æ™°åº¦
                    const edges = new THREE.EdgesGeometry(roomGeometry);
                    const lineSegments = new THREE.LineSegments(
                        edges,
                        new THREE.LineBasicMaterial({
                            color: roomColor,
                            transparent: true,
                            opacity: 0.6,
                            linewidth: 1
                        })
                    );
                    lineSegments.position.copy(roomMesh.position);
                    lineSegments.userData = { floor: floorKey };
                    group.add(lineSegments);

                    // æ·»åŠ æˆ¿é–“å®¶å…·å’Œè¨­å‚™
                    addFurnitureToRoom(group, room, yOffset, height, roomColor);
                });

                // å»ºé€ æˆ¿é–“ä¹‹é–“çš„å…§éƒ¨åˆ†éš”ç‰†
                const wallMaterial = new THREE.MeshStandardMaterial({
                    color: 0xd3d3d3,
                    metalness: 0.1,
                    roughness: 0.9
                });

                // ç‚ºæ¯å€‹æˆ¿é–“å‰µå»ºé‚Šç•Œç‰†ï¼ˆä½¿ç”¨å‰é¢å·²å®šç¾©çš„ rooms é™£åˆ—ï¼‰
                rooms.forEach(room => {
                    const wallThickness = 0.2;
                    const wallHeight = height * 0.9;

                    // æˆ¿é–“çš„é‚Šç•Œ
                    const left = room.x - room.w / 2;
                    const right = room.x + room.w / 2;
                    const front = room.z - room.d / 2;
                    const back = room.z + room.d / 2;

                    // åŒ—ç‰†ï¼ˆå¾Œé¢ï¼‰
                    if (!isRoomAdjacent(rooms, room, 'north')) {
                        const northWall = new THREE.BoxGeometry(room.w + wallThickness * 2, wallHeight, wallThickness);
                        const northMesh = new THREE.Mesh(northWall, wallMaterial);
                        northMesh.position.set(room.x, yOffset + height / 2, back + wallThickness / 2);
                        northMesh.castShadow = true;
                        northMesh.receiveShadow = true;
                        northMesh.userData = { floor: floorKey, type: 'interior_wall', isWall: true };
                        group.add(northMesh);
                    }

                    // å—ç‰†ï¼ˆå‰é¢ï¼‰
                    if (!isRoomAdjacent(rooms, room, 'south')) {
                        const southWall = new THREE.BoxGeometry(room.w + wallThickness * 2, wallHeight, wallThickness);
                        const southMesh = new THREE.Mesh(southWall, wallMaterial);
                        southMesh.position.set(room.x, yOffset + height / 2, front - wallThickness / 2);
                        southMesh.castShadow = true;
                        southMesh.receiveShadow = true;
                        southMesh.userData = { floor: floorKey, type: 'interior_wall', isWall: true };
                        group.add(southMesh);
                    }

                    // æ±ç‰†ï¼ˆå³é‚Šï¼‰
                    if (!isRoomAdjacent(rooms, room, 'east')) {
                        const eastWall = new THREE.BoxGeometry(wallThickness, wallHeight, room.d);
                        const eastMesh = new THREE.Mesh(eastWall, wallMaterial);
                        eastMesh.position.set(right + wallThickness / 2, yOffset + height / 2, room.z);
                        eastMesh.castShadow = true;
                        eastMesh.receiveShadow = true;
                        eastMesh.userData = { floor: floorKey, type: 'interior_wall', isWall: true };
                        group.add(eastMesh);
                    }

                    // è¥¿ç‰†ï¼ˆå·¦é‚Šï¼‰
                    if (!isRoomAdjacent(rooms, room, 'west')) {
                        const westWall = new THREE.BoxGeometry(wallThickness, wallHeight, room.d);
                        const westMesh = new THREE.Mesh(westWall, wallMaterial);
                        westMesh.position.set(left - wallThickness / 2, yOffset + height / 2, room.z);
                        westMesh.castShadow = true;
                        westMesh.receiveShadow = true;
                        westMesh.userData = { floor: floorKey, type: 'interior_wall', isWall: true };
                        group.add(westMesh);
                    }
                });

                yOffset += height;
            });

            return group;
        }

        function animate() {
            requestAnimationFrame(animate);

            frameCount++;
            const now = Date.now();
            if (now >= lastTime + 1000) {
                fps = frameCount;
                document.getElementById('fps-display').textContent = fps;
                frameCount = 0;
                lastTime = now;
            }

            // æ ¹æ“šç•¶å‰æ¨¡å¼æ›´æ–°æ§åˆ¶å’Œç›¸æ©Ÿ
            if (currentMode === 'exterior') {
                orbitControls.update();
                renderer.render(scene, orbitCamera);
            } else if (currentMode === 'interior') {
                // å…§éƒ¨å°è¦½ - ä½¿ç”¨ Minecraft é¢¨æ ¼çš„ç›¸æ©Ÿæ§åˆ¶ï¼ˆæ”¯æ´ WASD + æ»‘é¼ çœ‹ï¼‰
                updateFPSMovement();  // åŒæ™‚è™•ç†ç§»å‹•å’Œç›¸æ©Ÿæ—‹è½‰
                renderer.render(scene, fpsCamera);
            } else if (currentMode === 'fps') {
                // ç¬¬ä¸€äººç¨±è¦–è§’ - ä½¿ç”¨ Minecraft é¢¨æ ¼çš„ç›¸æ©Ÿæ§åˆ¶
                updateFPSMovement();
                renderer.render(scene, fpsCamera);
            }
        }

        // ğŸ”§ FIX: è¨ˆç®—æ¨“å±¤é‚Šç•Œï¼ˆå»ºç¯‰å¯¬åº¦å’Œæ·±åº¦ï¼‰- èˆ‡å¤–ç‰†é‚Šç•Œå°é½Š
        function getFloorBounds() {
            const wallThickness = 0.3;  // å¤–ç‰†åšåº¦
            const safeMargin = 0.5;     // é¡å¤–å®‰å…¨è·é›¢ï¼ˆé˜²æ­¢å¡åœ¨ç‰†è£¡ï¼‰
            return {
                minX: -BUILDING_CONFIG.width / 2 + wallThickness + safeMargin,
                maxX: BUILDING_CONFIG.width / 2 - wallThickness - safeMargin,
                minZ: -BUILDING_CONFIG.depth / 2 + wallThickness + safeMargin,
                maxZ: BUILDING_CONFIG.depth / 2 - wallThickness - safeMargin
            };
        }

        // Minecraft é¢¨æ ¼çš„ FPS ç§»å‹•æ§åˆ¶
        function updateFPSMovement() {
            const direction = new THREE.Vector3();

            // åŸºæ–¼ç›¸æ©Ÿæ—‹è½‰è¨ˆç®—ç§»å‹•æ–¹å‘ï¼ˆç›¸å°æ–¼ç›¸æ©Ÿæœå‘ï¼‰
            // yaw æ˜¯å·¦å³çœ‹ï¼Œpitch æ˜¯ä¸Šä¸‹çœ‹
            const forward = new THREE.Vector3(
                Math.sin(minecraftControls.yaw),
                0,
                Math.cos(minecraftControls.yaw)
            );

            const right = new THREE.Vector3(
                Math.sin(minecraftControls.yaw + Math.PI / 2),
                0,
                Math.cos(minecraftControls.yaw + Math.PI / 2)
            );

            // æ ¹æ“šæŒ‰éµç‹€æ…‹è¨­ç½®ç§»å‹•æ–¹å‘ï¼ˆç›¸æ©Ÿç›¸å°ï¼‰
            if (moveVector.forward) {
                direction.add(forward);
            }
            if (moveVector.backward) {
                direction.sub(forward);
            }
            if (moveVector.right) {
                direction.add(right);
            }
            if (moveVector.left) {
                direction.sub(right);
            }

            if (direction.length() > 0) {
                direction.normalize();
                const moveAmount = direction.clone().multiplyScalar(FPS_SPEED);
                const rayStart = fpsCamera.position.clone();

                // ç§»å‹•å‰æª¢æŸ¥ç›®æ¨™ä½ç½®
                const newPos = rayStart.clone().add(moveAmount);

                // ========== ğŸ”§ FIX: å®Œæ•´çš„é‚Šç•Œæª¢æŸ¥å’Œç¢°æ’æª¢æ¸¬ ==========

                // 1ï¸âƒ£ å‚ç›´é‚Šç•Œæª¢æŸ¥ (é˜²æ­¢ç©¿é€åœ°æ¿å’Œå¤©èŠ±æ¿)
                const currentFloorIndex = BUILDING_CONFIG.floors.indexOf(currentFloor);
                let floorBaseY = 0;
                let ceilingY = BUILDING_CONFIG.floorHeights[0];

                for (let i = 0; i < currentFloorIndex; i++) {
                    floorBaseY += BUILDING_CONFIG.floorHeights[i];
                }
                ceilingY = floorBaseY + BUILDING_CONFIG.floorHeights[currentFloorIndex];

                // æ”åƒæ©Ÿé«˜åº¦ç´„æŸ (é˜²æ­¢ç©¿é€åœ°æ¿å’Œå¤©èŠ±æ¿)
                const cameraEyeHeight = 0.2;  // çœ¼ç›èˆ‡åœ°æ¿çš„è·é›¢
                const minY = floorBaseY + cameraEyeHeight;
                const maxY = ceilingY - cameraEyeHeight;

                newPos.y = Math.max(minY, Math.min(maxY, newPos.y));

                // 2ï¸âƒ£ æ°´å¹³é‚Šç•Œæª¢æŸ¥ (é˜²æ­¢èµ°å‡ºå»ºç¯‰å¤–)
                const bounds = getFloorBounds();
                newPos.x = Math.max(bounds.minX, Math.min(bounds.maxX, newPos.x));
                newPos.z = Math.max(bounds.minZ, Math.min(bounds.maxZ, newPos.z));

                // 3ï¸âƒ£ ç¢°æ’æª¢æ¸¬ - å„ªå…ˆæª¢æ¸¬å¤–ç‰†ç¢°æ’
                const rayDir = moveAmount.clone().normalize();
                const moveDistance = moveAmount.length();

                raycaster.set(rayStart, rayDir);
                const intersects = raycaster.intersectObjects(scene.children, true);

                let canMove = true;
                const safeDistance = 0.3;  // èˆ‡ç‰†å£çš„å®‰å…¨è·é›¢

                // åˆ†é›¢ç‰†é«”å’Œéç‰†é«”ç¢°æ’
                let wallIntersects = [];
                let otherIntersects = [];

                intersects.forEach(intersect => {
                    if (intersect.object.userData && intersect.object.userData.isWall) {
                        wallIntersects.push(intersect);
                    } else {
                        otherIntersects.push(intersect);
                    }
                });

                // å„ªå…ˆæª¢æŸ¥å¤–ç‰†ç¢°æ’ï¼ˆé˜²æ­¢ç©¿é€å»ºç¯‰é‚Šç•Œï¼‰
                if (wallIntersects.length > 0) {
                    const closestWall = wallIntersects[0];
                    if (closestWall.distance < safeDistance) {
                        canMove = false;
                    }
                }
                // æ¬¡è¦æª¢æŸ¥å…¶ä»–ç¢°æ’ï¼ˆå¦‚å®¶å…·ï¼‰
                else if (otherIntersects.length > 0) {
                    const closestOther = otherIntersects[0];
                    if (closestOther.distance < safeDistance) {
                        canMove = false;
                    }
                }

                // ========== âœ… æ‡‰ç”¨æ–°ä½ç½® ==========
                if (canMove) {
                    fpsCamera.position.copy(newPos);
                }
            }

            // æ ¹æ“š pitch å’Œ yaw æ›´æ–°ç›¸æ©Ÿæ—‹è½‰
            // é™åˆ¶ pitch ä»¥é˜²æ­¢å®Œå…¨ç¿»è½‰
            const maxPitch = Math.PI / 2 * 0.99;
            minecraftControls.pitch = Math.max(-maxPitch, Math.min(maxPitch, minecraftControls.pitch));

            // æ‡‰ç”¨æ—‹è½‰åˆ°ç›¸æ©Ÿï¼ˆMinecraft é¢¨æ ¼ï¼‰
            fpsCamera.rotation.order = 'YXZ';
            fpsCamera.rotation.y = minecraftControls.yaw;
            fpsCamera.rotation.x = minecraftControls.pitch;
        }

        // ==================== UI æ§åˆ¶ ====================

        function switchMode(mode) {
            currentMode = mode;
            window.currentMode = mode;  // åŒæ™‚æ›´æ–°å…¨å±€è®Šæ•¸
            document.querySelectorAll('.mode-btn').forEach(btn => {
                if (btn.textContent.includes(mode === 'exterior' ? 'å¤–' : mode === 'interior' ? 'å…§' : 'äºº')) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // FPS æ¨¡å¼å°ˆç”¨UIï¼šåˆ‡æ›æˆ¿é–“é¢æ¿å’Œåˆ‡æ›æŒ‰éˆ•çš„å¯è¦‹æ€§
            const toggleBtn = document.getElementById('fps-room-toggle-btn');
            const roomPanel = document.getElementById('fps-room-panel');
            if (mode === 'fps') {
                // é€²å…¥ FPS æ¨¡å¼ï¼šé¡¯ç¤ºåˆ‡æ›æŒ‰éˆ•å’Œæˆ¿é–“é¢æ¿
                if (toggleBtn) toggleBtn.classList.add('visible');
                if (roomPanel) roomPanel.classList.add('visible');
            } else {
                // é›¢é–‹ FPS æ¨¡å¼ï¼šéš±è—åˆ‡æ›æŒ‰éˆ•å’Œæˆ¿é–“é¢æ¿
                if (toggleBtn) toggleBtn.classList.remove('visible');
                if (roomPanel) roomPanel.classList.remove('visible');
            }

            // æ ¹æ“šæ¨¡å¼è¨­ç½®ç›¸æ©Ÿå’Œæ§åˆ¶å™¨
            if (mode === 'exterior') {
                // å¤–éƒ¨è¦–è§’ - å•Ÿç”¨ OrbitControls
                orbitControls.enabled = true;  // âœ… å•Ÿç”¨ OrbitControls
                orbitControls.object = orbitCamera;
                orbitControls.autoRotate = true;
                orbitCamera.position.set(80, 60, 80);
                orbitControls.target.set(0, 15, 0);
                orbitControls.update();

                // é¡¯ç¤ºå¤–ç‰†
                scene.children.forEach(child => {
                    if (child.userData.floor) {
                        child.visible = true;
                    }
                });
            } else if (mode === 'interior') {
                // å…§éƒ¨å°è¦½ - Minecraft é¢¨æ ¼æ§åˆ¶ï¼ˆWASD + é¼ æ¨™çœ‹ï¼Œç„¡ Pointer Lockï¼‰
                // âŒ ç¦æ­¢ OrbitControls - ä½¿ç”¨ Minecraft æ§åˆ¶ä»£æ›¿
                orbitControls.autoRotate = false;
                orbitControls.enabled = false;  // ç¦ç”¨ OrbitControls

                // é€²å…¥å»ºç¯‰å…§éƒ¨ï¼Œåˆ‡æ›åˆ° 1Fï¼ˆå¦‚æœå·²é¸æ“‡å…¶ä»–æ¨“å±¤å‰‡ä¿æŒï¼‰
                const floorIndex = BUILDING_CONFIG.floors.indexOf(currentFloor);
                let floorCenterY = 0;
                for (let i = 0; i < floorIndex; i++) {
                    floorCenterY += BUILDING_CONFIG.floorHeights[i];
                }

                // æŠŠç›¸æ©Ÿæ”¾åœ¨è©²æ¨“å±¤å…§éƒ¨çš„ä¸­å¤®ä½ç½®ï¼Œé¢å‘å‰æ–¹
                fpsCamera.position.set(0, floorCenterY + FPS_HEIGHT, 0);
                minecraftControls.yaw = 0;  // é¢å‘å‰æ–¹ï¼ˆ+Z æ–¹å‘ï¼‰
                minecraftControls.pitch = 0;

                // âœ… é‡‹æ”¾ Pointer Lockï¼ˆå…§éƒ¨å°è¦½ä¸ä½¿ç”¨å®Œæ•´é–å®šï¼‰
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
                isPointerLocked = false;

                // é¡¯ç¤ºæ‰€æœ‰å…§éƒ¨å¹¾ä½•
                scene.children.forEach(child => {
                    if (child.userData && child.userData.floor) {
                        child.visible = true;
                    }
                });
            } else if (mode === 'fps') {
                // ç¬¬ä¸€äººç¨±è¦–è§’ - è¡—æ™¯å°èˆªæ¨¡å¼ï¼ˆGoogle Maps Street View é¢¨æ ¼ï¼‰
                // âŒ ç¦æ­¢ OrbitControls
                orbitControls.enabled = false;
                orbitControls.autoRotate = false;

                // å•Ÿç”¨è¡—æ™¯å°èˆª
                streetViewNav.enabled = true;
                generateWaypoints(currentFloor);
                createNavigationMarkers();

                // é€²å…¥å»ºç¯‰å…§éƒ¨ï¼Œä½¿ç”¨ç•¶å‰æ¨“å±¤
                const floorIndex = BUILDING_CONFIG.floors.indexOf(currentFloor);
                let floorCenterY = 0;
                for (let i = 0; i < floorIndex; i++) {
                    floorCenterY += BUILDING_CONFIG.floorHeights[i];
                }

                // æŠŠç›¸æ©Ÿæ”¾åœ¨è©²æ¨“å±¤ç¬¬ä¸€å€‹å°èˆªé»
                if (streetViewNav.waypoints.length > 0) {
                    fpsCamera.position.copy(streetViewNav.waypoints[0].position);
                    streetViewNav.currentWaypoint = streetViewNav.waypoints[0];
                } else {
                    fpsCamera.position.set(0, floorCenterY + FPS_HEIGHT, 0);
                }

                minecraftControls.yaw = 0;  // é¢å‘å‰æ–¹
                minecraftControls.pitch = 0;

                // âœ… é‡‹æ”¾ Pointer Lockï¼ˆè¡—æ™¯æ¨¡å¼ä¸éœ€è¦ï¼‰
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
                isPointerLocked = false;

                // é¡¯ç¤ºæ‰€æœ‰å…§éƒ¨å¹¾ä½•
                scene.children.forEach(child => {
                    if (child.userData && child.userData.floor) {
                        child.visible = true;
                    }
                });
            }
        }

        // éµç›¤äº‹ä»¶è™•ç†å™¨
        function onKeyDown(event) {
            switch (event.key.toLowerCase()) {
                case 'w': moveVector.forward = true; break;
                case 's': moveVector.backward = true; break;
                case 'a': moveVector.left = true; break;
                case 'd': moveVector.right = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.key.toLowerCase()) {
                case 'w': moveVector.forward = false; break;
                case 's': moveVector.backward = false; break;
                case 'a': moveVector.left = false; break;
                case 'd': moveVector.right = false; break;
            }
        }

        // Minecraft é¢¨æ ¼çš„é¼ æ¨™ç§»å‹•æ§åˆ¶ï¼ˆç›¸æ©Ÿæ—‹è½‰ï¼‰
        function onMouseMove(event) {
            if (currentMode === 'interior' || currentMode === 'fps') {
                const deltaX = event.clientX - minecraftControls.lastX;
                const deltaY = event.clientY - minecraftControls.lastY;

                // æ›´æ–°ç›¸æ©Ÿæ—‹è½‰ï¼ˆåœ¨ä»»ä½•æ™‚åˆ»ï¼Œåªæœ‰ç•¶æ»‘é¼ åœ¨ç•«å¸ƒä¸Šç§»å‹•æ™‚ï¼‰
                minecraftControls.yaw -= deltaX * minecraftControls.mouseSensitivity;
                minecraftControls.pitch -= deltaY * minecraftControls.mouseSensitivity;

                // è¨˜éŒ„æ–°ä½ç½®
                minecraftControls.lastX = event.clientX;
                minecraftControls.lastY = event.clientY;
            }
        }

        function selectFloor(floor) {
            currentFloor = floor;
            window.currentFloor = floor;  // åŒæ™‚æ›´æ–°å…¨å±€è®Šæ•¸
            document.querySelectorAll('.floor-btn').forEach(btn => {
                if (btn.textContent.includes(floor.substring(0, 2))) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // ========== ğŸ”§ FIX: æ›´æ–°3Då ´æ™¯ä¸­çš„æ¨“å±¤å¯è¦‹æ€§ ==========
            // ç•¶åˆ‡æ›æ¨“å±¤æ™‚ï¼Œéš±è—å…¶ä»–æ¨“å±¤çš„æ‰€æœ‰ç‰©é«”ï¼Œåªé¡¯ç¤ºç›®æ¨™æ¨“å±¤çš„ç‰©é«”
            if (scene && scene.children.length > 0) {
                scene.children.forEach(child => {
                    // å¦‚æœç‰©é«”æœ‰flooræ¨™ç±¤ï¼Œæ ¹æ“šæ¨“å±¤é€²è¡Œå¯è¦‹æ€§æ§åˆ¶
                    if (child.userData && child.userData.floor) {
                        child.visible = (child.userData.floor === floor);
                    }
                    // éè¿´æª¢æŸ¥å­ç‰©é«”ï¼ˆä¾‹å¦‚å®¶å…·ã€ç‰†é«”ç­‰ï¼‰
                    if (child.children && child.children.length > 0) {
                        child.children.forEach(subchild => {
                            if (subchild.userData && subchild.userData.floor) {
                                subchild.visible = (subchild.userData.floor === floor);
                            }
                        });
                    }
                });
            }
            // ========== âœ… æ¨“å±¤å¯è¦‹æ€§æ›´æ–°å®Œæˆ ==========

            // åœ¨å¤–éƒ¨è¦–è§’æ¨¡å¼ä¸‹ï¼Œæ›´æ–°ç›¸æ©Ÿä½ç½®ä¾†èšç„¦åˆ°è©²æ¨“å±¤
            if (currentMode === 'exterior') {
                // è¨ˆç®—è©²æ¨“å±¤çš„ä¸­å¿ƒyåæ¨™
                let floorIndex = BUILDING_CONFIG.floors.indexOf(floor);
                let floorCenterY = 0;

                // è¨ˆç®—æ¨“å±¤ä¸­å¿ƒé«˜åº¦
                for (let i = 0; i < floorIndex; i++) {
                    floorCenterY += BUILDING_CONFIG.floorHeights[i];
                }
                floorCenterY += BUILDING_CONFIG.floorHeights[floorIndex] / 2;

                // å¹³æ»‘åœ°ç§»å‹•ç›¸æ©Ÿåˆ°æ–°æ¨“å±¤
                orbitCamera.position.set(80, floorCenterY + 40, 80);
                orbitControls.target.set(0, floorCenterY, 0);
                orbitControls.update();
            }

            updateRoomsList();
            updateInfoPanel();
            drawMinimap();  // æ›´æ–°å°åœ°åœ–
        }

        function updateRoomsList() {
            const rooms = ROOM_DATA[currentFloor] || [];
            const html = rooms.map(room => `
                <div class="room-item" onclick="selectRoom('${room.id}')">
                    <div class="room-name">${room.name}</div>
                    <div class="room-area">${room.area} mÂ² â€¢ ${room.equipment[0]}</div>
                </div>
            `).join('');

            // æ›´æ–°å·¦å´é¢æ¿çš„æˆ¿é–“åˆ—è¡¨
            const roomsList = document.getElementById('rooms-list');
            if (roomsList) {
                roomsList.innerHTML = html;
            }

            // åŒæ™‚æ›´æ–°FPSæµ®å‹•é¢æ¿çš„æˆ¿é–“åˆ—è¡¨
            const fpsRoomsList = document.getElementById('fps-rooms-list');
            if (fpsRoomsList) {
                fpsRoomsList.innerHTML = html;
            }
        }

        function selectRoom(roomId) {
            const room = ROOM_DATA[currentFloor].find(r => r.id === roomId);
            if (room) {
                updateInfoPanel(room);

                // æ ¹æ“šç•¶å‰æ¨¡å¼é¸æ“‡å°èˆªæ–¹å¼
                if (currentMode === 'fps') {
                    // FPSæ¨¡å¼ï¼šä½¿ç”¨enterRoomé€²å…¥æˆ¿é–“
                    if (typeof enterRoom === 'function') {
                        enterRoom(roomId);
                        console.log('âœ… FPSå°èˆªåˆ°æˆ¿é–“:', room.name);
                    }
                } else {
                    // è»Œé“æ¨¡å¼ï¼šä½¿ç”¨OrbitControlså°èˆª
                    if (window.orbitControls && window.orbitCamera) {
                        const roomCenterX = room.x;  // ä½¿ç”¨room.xè€Œä¸æ˜¯room.x1
                        const roomCenterZ = room.z;  // ä½¿ç”¨room.zè€Œä¸æ˜¯room.y1
                        const floorHeight = BUILDING_CONFIG.floorHeights.slice(0,
                            BUILDING_CONFIG.floors.indexOf(currentFloor) + 1).reduce((a, b) => a + b, 0);
                        const roomCenterY = floorHeight - 2;

                        // è¨­å®šOrbitControlsç›®æ¨™é»
                        window.orbitControls.target.set(roomCenterX, roomCenterY, roomCenterZ);

                        // è¨ˆç®—æˆ¿é–“å°ºå¯¸
                        const roomWidth = room.w;
                        const roomDepth = room.d;
                        const roomSize = Math.max(roomWidth, roomDepth);

                        // èª¿æ•´æ”åƒæ©Ÿè·é›¢ä»¥é©æ‡‰æˆ¿é–“å¤§å°
                        const cameraDistance = roomSize * 1.5;
                        const angle = Math.PI / 4; // 45åº¦è§’

                        window.orbitCamera.position.x = roomCenterX + cameraDistance * Math.cos(angle);
                        window.orbitCamera.position.y = roomCenterY + cameraDistance * 0.6;
                        window.orbitCamera.position.z = roomCenterZ + cameraDistance * Math.sin(angle);

                        // å¹³æ»‘å‹•ç•«ï¼ˆå¯é¸ï¼‰
                        window.orbitControls.autoRotate = false;
                        console.log('âœ… è»Œé“å°èˆªåˆ°æˆ¿é–“:', room.name);
                    }
                }
            }
        }

        function updateInfoPanel(room = null) {
            const panel = document.getElementById('info-panel');
            if (!room) {
                const floorRooms = ROOM_DATA[currentFloor] || [];
                const totalArea = floorRooms.reduce((sum, r) => sum + r.area, 0);
                panel.innerHTML = `
                    <div class="info-card">
                        <div class="card-title">æ¨“å±¤çµ±è¨ˆ</div>
                        <div class="card-content">
                            <div class="info-row">
                                <span class="info-label">æ¨“å±¤</span>
                                <span class="info-value">${currentFloor}</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">æˆ¿é–“æ•¸</span>
                                <span class="info-value">${floorRooms.length}</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">ç¸½é¢ç©</span>
                                <span class="info-value">${totalArea} mÂ²</span>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                panel.innerHTML = `
                    <div class="info-card">
                        <div class="card-title">${room.name}</div>
                        <div class="card-content">
                            <div class="info-row">
                                <span class="info-label">æˆ¿é–“ ID</span>
                                <span class="info-value">${room.id}</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">é¢ç©</span>
                                <span class="info-value">${room.area} mÂ²</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">é¡å‹</span>
                                <span class="info-value">${room.type}</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">è¨­å‚™</span>
                            </div>
                            ${room.equipment.map(eq => `
                                <div style="color: #888; font-size: 11px; padding: 4px 0; padding-left: 10px;">â€¢ ${eq}</div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
        }

        function toggleWireframe() {
            scene.traverse(obj => {
                if (obj.material && obj.material.wireframe !== undefined) {
                    obj.material.wireframe = !obj.material.wireframe;
                }
            });
        }

        function toggleAutoRotate() {
            orbitControls.autoRotate = !orbitControls.autoRotate;
        }

        function resetView() {
            orbitCamera.position.set(80, 60, 80);
            orbitControls.target.set(0, 15, 0);
            orbitControls.update();
        }

        function toggleHelp() {
            const helpText = `
ğŸ® ä¸‰ç¨®è¦–è§’æ¨¡å¼:

ã€å¤–éƒ¨è¦–è§’ã€‘
â€¢ æ»‘é¼ å·¦éµæ‹–å‹•: æ—‹è½‰è¦–è§’
â€¢ æ»‘é¼ æ»¾è¼ª: æ”¾å¤§/ç¸®å°
â€¢ æ»‘é¼ å³éµæ‹–å‹•: å¹³ç§»è¦–è§’

ã€å…§éƒ¨å°è¦½ã€‘
â€¢ æ»‘é¼ å·¦éµæ‹–å‹•: æ—‹è½‰è¦–è§’
â€¢ æ»‘é¼ æ»¾è¼ª: æ”¾å¤§/ç¸®å°
â€¢ é»æ“Šæ¨“å±¤/æˆ¿é–“æŸ¥çœ‹è©³æƒ…

ã€ç¬¬ä¸€äººç¨±è¦–è§’ã€‘
â€¢ W/A/S/D: ç§»å‹• (å‰/å·¦/å¾Œ/å³)
â€¢ æ»‘é¼ ç§»å‹•: è½‰èº«/çœ‹å‘
â€¢ é»æ“Šç•«é¢: é–å®šæ»‘é¼ (Pointer Lock)
â€¢ æŒ‰ ESC: é‡‹æ”¾æ»‘é¼ 

å…¶ä»–:
â€¢ ç·šæ¡†: åˆ‡æ›ç·šæ¡†é¡¯ç¤º
â€¢ è‡ªå‹•æ—‹è½‰: é–‹å•Ÿè‡ªå‹•æ—‹è½‰
â€¢ é‡ç½®è¦–è§’: å›åˆ°åˆå§‹è¦–è§’
            `;
            alert(helpText.trim());
        }

        // ==================== å°åœ°åœ–ç¹ªè£½ ====================
        function drawMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            if (!canvas || !currentFloor) return;

            const ctx = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 200;

            // æ¸…ç©ºcanvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, 200, 200);

            // ç¹ªè£½é‚Šæ¡†
            ctx.strokeStyle = 'rgba(0, 204, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, 200, 200);

            // ç²å–ç•¶å‰æ¨“å±¤çš„æˆ¿é–“æ•¸æ“š
            const rooms = ROOM_DATA[currentFloor] || [];
            if (rooms.length === 0) return;

            // è¨ˆç®—æ‰€æœ‰æˆ¿é–“çš„é‚Šç•Œä»¥æ­£ç¢ºç¸®æ”¾
            let minX = Infinity, maxX = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            rooms.forEach(room => {
                const roomLeft = room.x - room.w / 2;
                const roomRight = room.x + room.w / 2;
                const roomTop = room.z - room.d / 2;
                const roomBottom = room.z + room.d / 2;

                minX = Math.min(minX, roomLeft);
                maxX = Math.max(maxX, roomRight);
                minZ = Math.min(minZ, roomTop);
                maxZ = Math.max(maxZ, roomBottom);
            });

            // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹ä»¥é©æ‡‰æ•´å€‹æ¨“å±¤
            const padding = 10; // åƒç´ é‚Šè·
            const availableWidth = 200 - 2 * padding;
            const availableHeight = 200 - 2 * padding;

            const buildingWidth = maxX - minX;
            const buildingDepth = maxZ - minZ;

            const scaleX = availableWidth / buildingWidth;
            const scaleZ = availableHeight / buildingDepth;
            const scale = Math.min(scaleX, scaleZ); // ä½¿ç”¨è¼ƒå°çš„ç¸®æ”¾ä¿æŒæ¯”ä¾‹

            // ç¹ªè£½æˆ¿é–“
            rooms.forEach(room => {
                // æ­£ç¢ºåœ°å°‡3Dåæ¨™æ˜ å°„åˆ°2Dç•«å¸ƒ
                const x = (room.x - room.w / 2 - minX) * scale + padding;
                const y = (room.z - room.d / 2 - minZ) * scale + padding;
                const w = room.w * scale;
                const d = room.d * scale;

                // æ ¹æ“šæˆ¿é–“é¡å‹è‘—è‰²
                switch (room.type) {
                    case 'healthcare':
                        ctx.fillStyle = 'rgba(0, 255, 136, 0.6)';
                        break;
                    case 'activity':
                        ctx.fillStyle = 'rgba(0, 204, 255, 0.6)';
                        break;
                    case 'dining':
                        ctx.fillStyle = 'rgba(255, 170, 0, 0.6)';
                        break;
                    case 'technical':
                        ctx.fillStyle = 'rgba(255, 0, 127, 0.4)';
                        break;
                    default:
                        ctx.fillStyle = 'rgba(100, 100, 150, 0.5)';
                }
                ctx.fillRect(x, y, w, d);

                // ç¹ªè£½é‚Šæ¡†
                ctx.strokeStyle = 'rgba(0, 255, 136, 0.5)';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, w, d);
            });

            // ç¹ªè£½æ¨“å±¤æ¨™ç±¤
            ctx.fillStyle = '#00ccff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(currentFloor, 8, 8);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const aspect = width / height;

            // æ›´æ–°å…©å€‹ç›¸æ©Ÿ
            orbitCamera.aspect = aspect;
            orbitCamera.updateProjectionMatrix();
            fpsCamera.aspect = aspect;
            fpsCamera.updateProjectionMatrix();

            renderer.setSize(width, height);
        }

        // ==================== åˆå§‹åŒ– ====================
        window.addEventListener('load', () => {
            console.log('ğŸ“ é é¢è¼‰å…¥å®Œæˆï¼Œæª¢æŸ¥ Three.js åº«...');

            // ç­‰å¾… Three.js å’Œæ§åˆ¶å™¨åŠ è¼‰ï¼ˆæœ€å¤š 10 ç§’ï¼‰
            let attempts = 0;
            const maxAttempts = 100; // 100 Ã— 100ms = 10 ç§’

            // æœ¬åœ°èª¿è©¦æ—¥èªŒå‡½å¼
            function debugLog(msg) {
                const log = document.getElementById('debug-log');
                if (log) {
                    log.innerHTML += '\n' + msg;
                    log.scrollTop = log.scrollHeight;
                }
                console.log(msg);
            }

            function waitForLibraries() {
                attempts++;

                // æª¢æŸ¥æ‰€æœ‰å¿…éœ€çš„åº«æ˜¯å¦å·²åŠ è¼‰
                const hasThree = typeof THREE !== 'undefined';
                const hasOrbitControls = typeof THREE !== 'undefined' && window.OrbitControls !== undefined;
                const hasPointerLock = typeof THREE !== 'undefined' && window.PointerLockControls !== undefined;

                if (hasThree && hasOrbitControls && hasPointerLock) {
                    debugLog('âœ… æ‰€æœ‰åº«å·²åŠ è¼‰');
                    debugLog('  â€¢ THREE: âœ“');
                    debugLog('  â€¢ OrbitControls: âœ“');
                    debugLog('  â€¢ PointerLockControls: âœ“');

                    checkThreeJS(); // åˆå§‹åŒ– raycaster å’Œ velocity

                    // é©—è­‰ä¸¦ç´„æŸæ‰€æœ‰æˆ¿é–“ä½ç½®åœ¨å»ºç¯‰é‚Šç•Œå…§
                    console.log('ğŸ” é©—è­‰æˆ¿é–“é‚Šç•Œ...');
                    validateAllRoomBounds();

                    console.log('ğŸ—ï¸ åˆå§‹åŒ– Three.js å ´æ™¯...');
                    initThreeJS();
                    updateRoomsList();
                    updateInfoPanel();
                    document.getElementById('obj-display').textContent = scene.children.length;

                    // æš´éœ²å…¨å±€è®Šæ•¸ä¾›æ¸¬è©¦ä½¿ç”¨
                    window.currentFloor = currentFloor;
                    window.currentMode = currentMode;
                    window.ROOM_DATA = ROOM_DATA;
                    window.fpsCamera = fpsCamera;
                    window.orbitCamera = orbitCamera;
                    window.scene = scene;
                    window.selectFloor = selectFloor;
                    window.updateRoomsList = updateRoomsList;
                    window.updateInfoPanel = updateInfoPanel;
                    window.switchMode = switchMode;
                    window.drawMinimap = drawMinimap;
                    window.toggleWireframe = toggleWireframe;
                    window.toggleAutoRotate = toggleAutoRotate;
                    window.resetView = resetView;
                    window.toggleHelp = toggleHelp;

                    // ==================== FPS æˆ¿é–“é¢æ¿äº‹ä»¶ç›£è½ ====================
                    // æˆ¿é–“é¢æ¿åˆ‡æ›æŒ‰éˆ•
                    const toggleBtn = document.getElementById('fps-room-toggle-btn');
                    const roomPanel = document.getElementById('fps-room-panel');
                    const closeBtn = document.getElementById('fps-room-close-btn');

                    if (toggleBtn && roomPanel) {
                        // åˆ‡æ›æŒ‰éˆ•é»æ“Šäº‹ä»¶
                        toggleBtn.addEventListener('click', () => {
                            roomPanel.classList.toggle('visible');
                            console.log('ğŸ”„ FPSæˆ¿é–“é¢æ¿åˆ‡æ›ï¼Œç•¶å‰ç‹€æ…‹:', roomPanel.classList.contains('visible'));
                        });

                        // é—œé–‰æŒ‰éˆ•é»æ“Šäº‹ä»¶
                        if (closeBtn) {
                            closeBtn.addEventListener('click', (e) => {
                                e.stopPropagation();  // é˜²æ­¢äº‹ä»¶å†’æ³¡
                                roomPanel.classList.remove('visible');
                                console.log('âœ• FPSæˆ¿é–“é¢æ¿å·²é—œé–‰');
                            });
                        }

                        // é»æ“Šé¢æ¿å¤–éƒ¨æ™‚éš±è—é¢æ¿ï¼ˆå¯é¸ï¼‰
                        document.addEventListener('click', (e) => {
                            if (!roomPanel.contains(e.target) && !toggleBtn.contains(e.target)) {
                                if (roomPanel.classList.contains('visible')) {
                                    roomPanel.classList.remove('visible');
                                }
                            }
                        });
                    }

                    // åˆå§‹åŒ–å°åœ°åœ–
                    setTimeout(drawMinimap, 500);

                    console.log('âœ… åˆå§‹åŒ–å®Œæˆï¼Œ3D å»ºç¯‰æ‡‰è©²å‡ºç¾äº†');
                } else if (attempts < maxAttempts) {
                    const missing = [];
                    if (!hasThree) missing.push('THREE');
                    if (!hasOrbitControls) missing.push('OrbitControls');
                    if (!hasPointerLock) missing.push('PointerLockControls');
                    console.log(`â³ ç­‰å¾…åº«åŠ è¼‰... (${attempts}/${maxAttempts}) [ç¼ºå°‘: ${missing.join(', ')}]`);
                    setTimeout(waitForLibraries, 100);
                } else {
                    console.error('âŒ åº«åŠ è¼‰è¶…æ™‚');
                    alert('âŒ 3D å ´æ™¯åŠ è¼‰å¤±æ•—ï¼Œè«‹é‡æ–°æ•´ç†é é¢');
                }
            }

            waitForLibraries();
        });
    </script>
</body>
</html>
